{
  "address": "0xB715A51a02d551406D8508EB18b0724215C4Ea42",
  "abi": [],
  "transactionHash": "0x9b1c1b5efeb67032b47ba8ca7f02ca1b4d8fa05612fc0c09129235e448fe7aa1",
  "receipt": {
    "to": null,
    "from": "0x1c745d31A084a14Ba30E7c9F4B14EA762d44f194",
    "contractAddress": "0xB715A51a02d551406D8508EB18b0724215C4Ea42",
    "transactionIndex": 0,
    "gasUsed": "23779695",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xe51539be482c9e55e73581e09a23d64f37fadc26ece18c17ffe5c8564919bc71",
    "transactionHash": "0x9b1c1b5efeb67032b47ba8ca7f02ca1b4d8fa05612fc0c09129235e448fe7aa1",
    "logs": [],
    "blockNumber": 10770228,
    "cumulativeGasUsed": "10962714",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "63d119c4dca0c049815023a60c5667e0",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"addUsdcPosition(TraderVaultLib.TraderVault storage,int256)\":{\"params\":{\"_traderVault\":\"trader vault object\",\"_usdcPositionToAdd\":\"amount to add. value is always positive.\"}},\"decreaseLiquidationReward(TraderVaultLib.TraderVault storage,int256,int256)\":{\"params\":{\"_liquidationFee\":\"liquidation fee rate\",\"_minCollateral\":\"min collateral\",\"_traderVault\":\"trader vault object\"}},\"setInsolvencyFlagIfNeeded(TraderVaultLib.TraderVault storage)\":{\"params\":{\"_traderVault\":\"trader vault object\"}},\"updateUsdcPosition(TraderVaultLib.TraderVault storage,int256,IPerpetualMarketCore.TradePriceInfo)\":{\"params\":{\"_tradePriceInfo\":\"trade price info\",\"_traderVault\":\"trader vault object\",\"_usdcPositionToAdd\":\"amount to add. if positive then increase amount, if negative then decrease amount.\"},\"returns\":{\"finalUsdcPosition\":\"positive means amount of deposited margin and negative means amount of withdrawn margin.\"}},\"updateVault(TraderVaultLib.TraderVault storage,uint256,uint256,int128,uint256,int256)\":{\"params\":{\"_fundingFeePerPosition\":\"entry funding fee paid per position\",\"_positionPerpetual\":\"amount of position to increase or decrease\",\"_productId\":\"product id\",\"_subVaultIndex\":\"index of sub-vault\",\"_tradePrice\":\"trade price\",\"_traderVault\":\"trader vault object\"}}},\"stateVariables\":{\"MIN_MARGIN\":{\"details\":\"minimum margin is 500 USDC\"},\"RISK_PARAM_FOR_VAULT\":{\"details\":\"risk parameter for MinCollateral calculation is 5.0%\"}},\"title\":\"TraderVaultLib\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addUsdcPosition(TraderVaultLib.TraderVault storage,int256)\":{\"notice\":\"Add USDC position\"},\"decreaseLiquidationReward(TraderVaultLib.TraderVault storage,int256,int256)\":{\"notice\":\"Decreases liquidation reward from usdc position\"},\"setInsolvencyFlagIfNeeded(TraderVaultLib.TraderVault storage)\":{\"notice\":\"Set insolvency flag if needed If PositionValue is negative, set insolvency flag.\"},\"updateUsdcPosition(TraderVaultLib.TraderVault storage,int256,IPerpetualMarketCore.TradePriceInfo)\":{\"notice\":\"Updates USDC position\"},\"updateVault(TraderVaultLib.TraderVault storage,uint256,uint256,int128,uint256,int256)\":{\"notice\":\"Updates positions in the vault\"}},\"notice\":\"TraderVaultLib has functions to calculate position value and minimum collateral for implementing cross margin wallet. Data Structure  Vault  - PositionUSDC  - SubVault0(PositionPerpetuals, EntryPrices, entryFundingFee)  - SubVault1(PositionPerpetuals, EntryPrices, entryFundingFee)  - ...  PositionPerpetuals = [PositionSqueeth, PositionFuture]  EntryPrices = [EntryPriceSqueeth, EntryPriceFuture]  entryFundingFee = [entryFundingFeeqeeth, FundingFeeEntryValueFuture] Error codes  T0: PositionValue must be greater than MinCollateral  T1: PositionValue must be less than MinCollateral  T2: Vault is insolvent  T3: subVaultIndex is too large  T4: position must not be 0  T5: usdc to add must be positive\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/lib/TraderVaultLib.sol\":\"TraderVaultLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xe22a1fc7400ae196eba2ad1562d0386462b00a6363b742d55a2fd2021a58586f\",\"license\":\"MIT\"},\"@openzeppelin/contracts/math/SignedSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title SignedSafeMath\\n * @dev Signed math operations with safety checks that revert on error.\\n */\\nlibrary SignedSafeMath {\\n    int256 constant private _INT256_MIN = -2**255;\\n\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int256 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 && a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\",\"keccak256\":\"0xba085261d44cf28d2583f7c8cdb2f0a6a495ff1a640f86d995ea9d36b42b0046\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= -2**127 && value < 2**127, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= -2**63 && value < 2**63, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= -2**31 && value < 2**31, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= -2**15 && value < 2**15, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= -2**7 && value < 2**7, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(value < 2**255, \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x79004a1d1471abe87e92c4497acba06d5dfa5b1f3e9894a0991a7c4669c5c02c\",\"license\":\"MIT\"},\"contracts/interfaces/IPerpetualMarketCore.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../lib/NettingLib.sol\\\";\\n\\ninterface IPerpetualMarketCore {\\n    struct TradePriceInfo {\\n        uint128 spotPrice;\\n        int256[2] tradePrices;\\n        int256[2] fundingRates;\\n        int128[2] amountsFundingPaidPerPosition;\\n    }\\n\\n    function initialize(\\n        address _depositor,\\n        uint256 _depositAmount,\\n        int256 _initialFundingRate\\n    ) external returns (uint256 mintAmount);\\n\\n    function deposit(address _depositor, uint256 _depositAmount) external returns (uint256 mintAmount);\\n\\n    function withdraw(address _withdrawer, uint256 _withdrawnAmount) external returns (uint256 burnAmount);\\n\\n    function addLiquidity(uint256 _amount) external;\\n\\n    function updatePoolPosition(uint256 _productId, int128 _tradeAmount)\\n        external\\n        returns (\\n            uint256 tradePrice,\\n            int256,\\n            uint256 protocolFee\\n        );\\n\\n    function completeHedgingProcedure(NettingLib.CompleteParams memory _completeParams) external;\\n\\n    function updatePoolSnapshot() external;\\n\\n    function executeFundingPayment() external;\\n\\n    function getTradePriceInfo(int128[2] memory amountAssets) external view returns (TradePriceInfo memory);\\n\\n    function getTradePrice(uint256 _productId, int128 _tradeAmount)\\n        external\\n        view\\n        returns (\\n            int256,\\n            int256,\\n            int256,\\n            int256,\\n            int256\\n        );\\n\\n    function rebalance() external;\\n\\n    function getTokenAmountForHedging() external view returns (NettingLib.CompleteParams memory completeParams);\\n\\n    function getLPTokenPrice(int256 _deltaLiquidityAmount) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xc7cb9a7e856b7cdca89801119acab5bbf197765b81a68beccefc6d63e54d3d7c\",\"license\":\"agpl-3.0\"},\"contracts/lib/EntryPriceMath.sol\":{\"content\":\"//SPDX-License-Identifier: agpl-3.0\\npragma solidity =0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/utils/SafeCast.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SignedSafeMath.sol\\\";\\nimport \\\"./Math.sol\\\";\\n\\n/**\\n * @title EntryPriceMath\\n * @notice Library contract which has functions to calculate new entry price and profit\\n * from previous entry price and trade price for implementing margin wallet.\\n */\\nlibrary EntryPriceMath {\\n    using SafeCast for uint256;\\n    using SafeMath for uint256;\\n    using SignedSafeMath for int256;\\n\\n    /**\\n     * @notice Calculates new entry price and return profit if position is closed\\n     *\\n     * Calculation Patterns\\n     *  |Position|PositionTrade|NewPosition|Pattern|\\n     *  |       +|            +|          +|      A|\\n     *  |       +|            -|          +|      B|\\n     *  |       +|            -|          -|      C|\\n     *  |       -|            -|          -|      A|\\n     *  |       -|            +|          -|      B|\\n     *  |       -|            +|          +|      C|\\n     *\\n     * Calculations\\n     *  Pattern A (open positions)\\n     *   NewEntryPrice = (EntryPrice * |Position| + TradePrce * |PositionTrade|) / (Position + PositionTrade)\\n     *\\n     *  Pattern B (close positions)\\n     *   NewEntryPrice = EntryPrice\\n     *   ProfitValue = -PositionTrade * (TradePrice - EntryPrice)\\n     *\\n     *  Pattern C (close all positions & open new)\\n     *   NewEntryPrice = TradePrice\\n     *   ProfitValue = Position * (TradePrice - EntryPrice)\\n     *\\n     * @param _entryPrice previous entry price\\n     * @param _position current position\\n     * @param _tradePrice trade price\\n     * @param _positionTrade position to trade\\n     * @return newEntryPrice new entry price\\n     * @return profitValue notional profit value when positions are closed\\n     */\\n    function updateEntryPrice(\\n        int256 _entryPrice,\\n        int256 _position,\\n        int256 _tradePrice,\\n        int256 _positionTrade\\n    ) internal pure returns (int256 newEntryPrice, int256 profitValue) {\\n        int256 newPosition = _position.add(_positionTrade);\\n        if (_position == 0 || (_position > 0 && _positionTrade > 0) || (_position < 0 && _positionTrade < 0)) {\\n            newEntryPrice = (\\n                _entryPrice.mul(int256(Math.abs(_position))).add(_tradePrice.mul(int256(Math.abs(_positionTrade))))\\n            ).div(int256(Math.abs(_position.add(_positionTrade))));\\n        } else if (\\n            (_position > 0 && _positionTrade < 0 && newPosition > 0) ||\\n            (_position < 0 && _positionTrade > 0 && newPosition < 0)\\n        ) {\\n            newEntryPrice = _entryPrice;\\n            profitValue = (-_positionTrade).mul(_tradePrice.sub(_entryPrice)) / 1e8;\\n        } else {\\n            if (newPosition != 0) {\\n                newEntryPrice = _tradePrice;\\n            }\\n\\n            profitValue = _position.mul(_tradePrice.sub(_entryPrice)) / 1e8;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x76b69923c0d21ff5a04335743b0b4f64ff36a90df6154f030914231abf47c858\",\"license\":\"agpl-3.0\"},\"contracts/lib/Math.sol\":{\"content\":\"//SPDX-License-Identifier: agpl-3.0\\npragma solidity =0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/SignedSafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n * Error codes\\n * M0: y is too small\\n * M1: y is too large\\n * M2: possible overflow\\n * M3: input should be positive number\\n * M4: cannot handle exponents greater than 100\\n */\\nlibrary Math {\\n    using SafeMath for uint256;\\n    using SignedSafeMath for int256;\\n\\n    /// @dev Min exp\\n    int256 private constant MIN_EXP = -63 * 1e8;\\n    /// @dev Max exp\\n    uint256 private constant MAX_EXP = 100 * 1e8;\\n    /// @dev ln(2) scaled by 1e8\\n    uint256 private constant LN_2_E8 = 69314718;\\n\\n    /**\\n     * @notice Return the addition of unsigned integer and sigined integer.\\n     * when y is negative reverting on negative result and when y is positive reverting on overflow.\\n     */\\n    function addDelta(uint256 x, int256 y) internal pure returns (uint256 z) {\\n        if (y < 0) {\\n            require((z = x - uint256(-y)) < x, \\\"M0\\\");\\n        } else {\\n            require((z = x + uint256(y)) >= x, \\\"M1\\\");\\n        }\\n    }\\n\\n    function abs(int256 x) internal pure returns (uint256) {\\n        return uint256(x >= 0 ? x : -x);\\n    }\\n\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? b : a;\\n    }\\n\\n    /**\\n     * @notice Returns scaled number.\\n     * Reverts if the scaler is greater than 50.\\n     */\\n    function scale(\\n        uint256 _a,\\n        uint256 _from,\\n        uint256 _to\\n    ) internal pure returns (uint256) {\\n        if (_from > _to) {\\n            require(_from - _to < 70, \\\"M2\\\");\\n            // (_from - _to) is safe because _from > _to.\\n            // 10**(_from - _to) is safe because it's less than 10**70.\\n            return _a.div(10**(_from - _to));\\n        } else if (_from < _to) {\\n            require(_to - _from < 70, \\\"M2\\\");\\n            // (_to - _from) is safe because _to > _from.\\n            // 10**(_to - _from) is safe because it's less than 10**70.\\n            return _a.mul(10**(_to - _from));\\n        } else {\\n            return _a;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x48b5c1ab1cf783b928b58b837dfbc83db49e59fb6e375c6e2ffd64982f437a26\",\"license\":\"agpl-3.0\"},\"contracts/lib/NettingLib.sol\":{\"content\":\"//SPDX-License-Identifier: agpl-3.0\\npragma solidity =0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/utils/SafeCast.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SignedSafeMath.sol\\\";\\nimport \\\"./Math.sol\\\";\\n\\n/**\\n * @title NettingLib\\n * Error codes\\n * N0: Unknown product id\\n * N1: Total delta must be greater than 0\\n * N2: No enough USDC\\n */\\nlibrary NettingLib {\\n    using SafeCast for int256;\\n    using SafeCast for uint128;\\n    using SafeCast for uint256;\\n    using SafeMath for uint256;\\n    using SafeMath for uint128;\\n    using SignedSafeMath for int256;\\n    using SignedSafeMath for int128;\\n\\n    struct AddMarginParams {\\n        int256 delta0;\\n        int256 delta1;\\n        int256 gamma1;\\n        int256 spotPrice;\\n        int256 poolMarginRiskParam;\\n    }\\n\\n    struct CompleteParams {\\n        uint256 amountUsdc;\\n        uint256 amountUnderlying;\\n        int256[2] amountsRequiredUnderlying;\\n        bool isLong;\\n    }\\n\\n    struct Info {\\n        uint128 amountAaveCollateral;\\n        uint128[2] amountsUsdc;\\n        int128[2] amountsUnderlying;\\n    }\\n\\n    /**\\n     * @notice Adds required margin for delta hedging\\n     */\\n    function addMargin(\\n        Info storage _info,\\n        uint256 _productId,\\n        AddMarginParams memory _params\\n    ) internal returns (int256 requiredMargin, int256 hedgePositionValue) {\\n        int256 totalRequiredMargin = getRequiredMargin(_productId, _params);\\n\\n        hedgePositionValue = getHedgePositionValue(_info, _params.spotPrice, _productId);\\n\\n        requiredMargin = totalRequiredMargin.sub(hedgePositionValue);\\n\\n        if (_info.amountsUsdc[_productId].toInt256().add(requiredMargin) < 0) {\\n            requiredMargin = -_info.amountsUsdc[_productId].toInt256();\\n        }\\n\\n        _info.amountsUsdc[_productId] = Math.addDelta(_info.amountsUsdc[_productId], requiredMargin).toUint128();\\n    }\\n\\n    function getRequiredTokenAmountsForHedge(\\n        int128[2] memory _amountsUnderlying,\\n        int256[2] memory _deltas,\\n        int256 _spotPrice\\n    ) internal pure returns (CompleteParams memory completeParams) {\\n        completeParams.amountsRequiredUnderlying[0] = -_amountsUnderlying[0] - _deltas[0];\\n        completeParams.amountsRequiredUnderlying[1] = -_amountsUnderlying[1] - _deltas[1];\\n\\n        int256 totalUnderlyingPosition = getTotalUnderlyingPosition(_amountsUnderlying);\\n\\n        // 1. Calculate required amount of underlying token\\n        int256 requiredUnderlyingAmount;\\n        {\\n            // required amount is -(net delta)\\n            requiredUnderlyingAmount = -_deltas[0].add(_deltas[1]).add(totalUnderlyingPosition);\\n\\n            if (_deltas[0].add(_deltas[1]) > 0) {\\n                // if pool delta is positive\\n                requiredUnderlyingAmount = -totalUnderlyingPosition;\\n\\n                completeParams.amountsRequiredUnderlying[0] = -_amountsUnderlying[0] + _deltas[1];\\n            }\\n\\n            completeParams.isLong = requiredUnderlyingAmount > 0;\\n        }\\n\\n        // 2. Calculate USDC and ETH amounts.\\n        completeParams.amountUnderlying = Math.abs(requiredUnderlyingAmount);\\n        completeParams.amountUsdc = (Math.abs(requiredUnderlyingAmount).mul(uint256(_spotPrice))) / 1e8;\\n\\n        return completeParams;\\n    }\\n\\n    /**\\n     * @notice Completes delta hedging procedure\\n     * Calculate holding amount of Underlying and USDC after a hedge.\\n     */\\n    function complete(Info storage _info, CompleteParams memory _params) internal {\\n        uint256 totalUnderlying = Math.abs(_params.amountsRequiredUnderlying[0]).add(\\n            Math.abs(_params.amountsRequiredUnderlying[1])\\n        );\\n\\n        require(totalUnderlying > 0, \\\"N1\\\");\\n\\n        for (uint256 i = 0; i < 2; i++) {\\n            _info.amountsUnderlying[i] = _info\\n                .amountsUnderlying[i]\\n                .add(_params.amountsRequiredUnderlying[i])\\n                .toInt128();\\n\\n            {\\n                uint256 deltaUsdcAmount = (_params.amountUsdc.mul(Math.abs(_params.amountsRequiredUnderlying[i]))).div(\\n                    totalUnderlying\\n                );\\n\\n                if (_params.isLong) {\\n                    require(_info.amountsUsdc[i] >= deltaUsdcAmount, \\\"N2\\\");\\n                    _info.amountsUsdc[i] = _info.amountsUsdc[i].sub(deltaUsdcAmount).toUint128();\\n                } else {\\n                    _info.amountsUsdc[i] = _info.amountsUsdc[i].add(deltaUsdcAmount).toUint128();\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets required margin\\n     * @param _productId Id of product to get required margin\\n     * @param _params parameters to calculate required margin\\n     * @return RequiredMargin scaled by 1e8\\n     */\\n    function getRequiredMargin(uint256 _productId, AddMarginParams memory _params) internal pure returns (int256) {\\n        int256 weightedDelta = calculateWeightedDelta(_productId, _params.delta0, _params.delta1);\\n\\n        if (_productId == 0) {\\n            return getRequiredMarginOfFuture(_params, weightedDelta);\\n        } else if (_productId == 1) {\\n            return getRequiredMarginOfSqueeth(_params, weightedDelta);\\n        } else {\\n            revert(\\\"N0\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets required margin for future\\n     * RequiredMargin_{future} = (1+\\u03b1)*S*|WeightedDelta|\\n     * @return RequiredMargin scaled by 1e8\\n     */\\n    function getRequiredMarginOfFuture(AddMarginParams memory _params, int256 _weightedDelta)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        int256 requiredMargin = (_params.spotPrice.mul(Math.abs(_weightedDelta).toInt256())) / 1e8;\\n        return ((1e4 + _params.poolMarginRiskParam).mul(requiredMargin)) / 1e4;\\n    }\\n\\n    /**\\n     * @notice Gets required margin for squeeth\\n     * RequiredMargin_{squeeth}\\n     * = max((1-\\u03b1) * S * |WeightDelta_{sqeeth}-\\u03b1 * S * gamma|, (1+\\u03b1) * S * |WeightDelta_{sqeeth}+\\u03b1 * S * gamma|)\\n     * @return RequiredMargin scaled by 1e8\\n     */\\n    function getRequiredMarginOfSqueeth(AddMarginParams memory _params, int256 _weightedDelta)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        int256 deltaFromGamma = (_params.poolMarginRiskParam.mul(_params.spotPrice).mul(_params.gamma1)) / 1e12;\\n\\n        return\\n            Math.max(\\n                (\\n                    (1e4 - _params.poolMarginRiskParam).mul(_params.spotPrice).mul(\\n                        Math.abs(_weightedDelta.sub(deltaFromGamma)).toInt256()\\n                    )\\n                ) / 1e12,\\n                (\\n                    (1e4 + _params.poolMarginRiskParam).mul(_params.spotPrice).mul(\\n                        Math.abs(_weightedDelta.add(deltaFromGamma)).toInt256()\\n                    )\\n                ) / 1e12\\n            );\\n    }\\n\\n    /**\\n     * @notice Gets notional value of hedge positions\\n     * HedgePositionValue_i = AmountsUsdc_i+AmountsUnderlying_i*S\\n     * @return HedgePositionValue scaled by 1e8\\n     */\\n    function getHedgePositionValue(\\n        Info memory _info,\\n        int256 _spot,\\n        uint256 _productId\\n    ) internal pure returns (int256) {\\n        int256 hedgeNotional = _spot.mul(_info.amountsUnderlying[_productId]) / 1e8;\\n\\n        return _info.amountsUsdc[_productId].toInt256().add(hedgeNotional);\\n    }\\n\\n    /**\\n     * @notice Gets total underlying position\\n     * TotalUnderlyingPosition = \\u03a3AmountsUnderlying_i\\n     */\\n    function getTotalUnderlyingPosition(int128[2] memory _amountsUnderlying)\\n        internal\\n        pure\\n        returns (int256 underlyingPosition)\\n    {\\n        for (uint256 i = 0; i < 2; i++) {\\n            underlyingPosition = underlyingPosition.add(_amountsUnderlying[i]);\\n        }\\n\\n        return underlyingPosition;\\n    }\\n\\n    /**\\n     * @notice Calculates weighted delta\\n     * WeightedDelta = delta_i * (\\u03a3delta_i) / (\\u03a3|delta_i|)\\n     * @return weighted delta scaled by 1e8\\n     */\\n    function calculateWeightedDelta(\\n        uint256 _productId,\\n        int256 _delta0,\\n        int256 _delta1\\n    ) internal pure returns (int256) {\\n        int256 netDelta = _delta0.add(_delta1);\\n        int256 totalDelta = (Math.abs(_delta0).add(Math.abs(_delta1))).toInt256();\\n\\n        require(totalDelta >= 0, \\\"N1\\\");\\n\\n        if (totalDelta == 0) {\\n            return 0;\\n        }\\n\\n        if (_productId == 0) {\\n            return (Math.abs(_delta0).toInt256().mul(netDelta)).div(totalDelta);\\n        } else if (_productId == 1) {\\n            return (Math.abs(_delta1).toInt256().mul(netDelta)).div(totalDelta);\\n        } else {\\n            revert(\\\"N0\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x46f6b430287b0cab11606278f5d69a3bd72d536e857a8e9601fa41a1f5ab48e9\",\"license\":\"agpl-3.0\"},\"contracts/lib/TraderVaultLib.sol\":{\"content\":\"//SPDX-License-Identifier: agpl-3.0\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/utils/SafeCast.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SignedSafeMath.sol\\\";\\nimport \\\"../interfaces/IPerpetualMarketCore.sol\\\";\\nimport \\\"./Math.sol\\\";\\nimport \\\"./EntryPriceMath.sol\\\";\\n\\n/**\\n * @title TraderVaultLib\\n * @notice TraderVaultLib has functions to calculate position value and minimum collateral for implementing cross margin wallet.\\n *\\n * Data Structure\\n *  Vault\\n *  - PositionUSDC\\n *  - SubVault0(PositionPerpetuals, EntryPrices, entryFundingFee)\\n *  - SubVault1(PositionPerpetuals, EntryPrices, entryFundingFee)\\n *  - ...\\n *\\n *  PositionPerpetuals = [PositionSqueeth, PositionFuture]\\n *  EntryPrices = [EntryPriceSqueeth, EntryPriceFuture]\\n *  entryFundingFee = [entryFundingFeeqeeth, FundingFeeEntryValueFuture]\\n *\\n *\\n * Error codes\\n *  T0: PositionValue must be greater than MinCollateral\\n *  T1: PositionValue must be less than MinCollateral\\n *  T2: Vault is insolvent\\n *  T3: subVaultIndex is too large\\n *  T4: position must not be 0\\n *  T5: usdc to add must be positive\\n */\\nlibrary TraderVaultLib {\\n    using SafeCast for int256;\\n    using SafeCast for uint256;\\n    using SafeCast for uint128;\\n    using SafeMath for uint256;\\n    using SignedSafeMath for int256;\\n    using SignedSafeMath for int128;\\n\\n    uint256 private constant MAX_PRODUCT_ID = 2;\\n\\n    /// @dev minimum margin is 500 USDC\\n    uint256 private constant MIN_MARGIN = 500 * 1e8;\\n\\n    /// @dev risk parameter for MinCollateral calculation is 5.0%\\n    uint256 private constant RISK_PARAM_FOR_VAULT = 500;\\n\\n    struct SubVault {\\n        int128[2] positionPerpetuals;\\n        uint128[2] entryPrices;\\n        int128[2] entryFundingFee;\\n    }\\n\\n    struct TraderVault {\\n        int128 positionUsdc;\\n        SubVault[] subVaults;\\n        bool isInsolvent;\\n    }\\n\\n    /**\\n     * @notice Gets amount of min collateral to add Squees/Future\\n     * @param _traderVault trader vault object\\n     * @param _tradeAmounts amount to trade\\n     * @param _tradePriceInfo trade price info\\n     * @return minCollateral and positionValue\\n     */\\n    function getMinCollateralToAddPosition(\\n        TraderVault memory _traderVault,\\n        int128[2] memory _tradeAmounts,\\n        IPerpetualMarketCore.TradePriceInfo memory _tradePriceInfo\\n    ) internal pure returns (int256 minCollateral) {\\n        int128[2] memory positionPerpetuals = getPositionPerpetuals(_traderVault);\\n\\n        for (uint256 i = 0; i < MAX_PRODUCT_ID; i++) {\\n            positionPerpetuals[i] = positionPerpetuals[i].add(_tradeAmounts[i]).toInt128();\\n        }\\n\\n        minCollateral = calculateMinCollateral(positionPerpetuals, _tradePriceInfo);\\n    }\\n\\n    /**\\n     * @notice Updates USDC position\\n     * @param _traderVault trader vault object\\n     * @param _usdcPositionToAdd amount to add. if positive then increase amount, if negative then decrease amount.\\n     * @param _tradePriceInfo trade price info\\n     * @return finalUsdcPosition positive means amount of deposited margin\\n     * and negative means amount of withdrawn margin.\\n     */\\n    function updateUsdcPosition(\\n        TraderVault storage _traderVault,\\n        int256 _usdcPositionToAdd,\\n        IPerpetualMarketCore.TradePriceInfo memory _tradePriceInfo\\n    ) external returns (int256 finalUsdcPosition) {\\n        finalUsdcPosition = _usdcPositionToAdd;\\n        require(!_traderVault.isInsolvent, \\\"T2\\\");\\n\\n        int256 positionValue = getPositionValue(_traderVault, _tradePriceInfo);\\n        int256 minCollateral = getMinCollateral(_traderVault, _tradePriceInfo);\\n        int256 maxWithdrawable = positionValue - minCollateral;\\n\\n        // If trader wants to withdraw all USDC, set maxWithdrawable.\\n        if (_usdcPositionToAdd < -maxWithdrawable && maxWithdrawable > 0 && _usdcPositionToAdd < 0) {\\n            finalUsdcPosition = -maxWithdrawable;\\n        }\\n\\n        _traderVault.positionUsdc = _traderVault.positionUsdc.add(finalUsdcPosition).toInt128();\\n\\n        require(!checkVaultIsLiquidatable(_traderVault, _tradePriceInfo), \\\"T0\\\");\\n    }\\n\\n    /**\\n     * @notice Add USDC position\\n     * @param _traderVault trader vault object\\n     * @param _usdcPositionToAdd amount to add. value is always positive.\\n     */\\n    function addUsdcPosition(TraderVault storage _traderVault, int256 _usdcPositionToAdd) external {\\n        require(!_traderVault.isInsolvent, \\\"T2\\\");\\n        require(_usdcPositionToAdd > 0, \\\"T5\\\");\\n\\n        _traderVault.positionUsdc = _traderVault.positionUsdc.add(_usdcPositionToAdd).toInt128();\\n    }\\n\\n    /**\\n     * @notice Gets total position of perpetuals in the vault\\n     * @param _traderVault trader vault object\\n     * @return positionPerpetuals are total amount of perpetual scaled by 1e8\\n     */\\n    function getPositionPerpetuals(TraderVault memory _traderVault)\\n        internal\\n        pure\\n        returns (int128[2] memory positionPerpetuals)\\n    {\\n        for (uint256 i = 0; i < MAX_PRODUCT_ID; i++) {\\n            positionPerpetuals[i] = getPositionPerpetual(_traderVault, i);\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets position of a perpetual in the vault\\n     * @param _traderVault trader vault object\\n     * @param _productId product id\\n     * @return positionPerpetual is amount of perpetual scaled by 1e8\\n     */\\n    function getPositionPerpetual(TraderVault memory _traderVault, uint256 _productId)\\n        internal\\n        pure\\n        returns (int128 positionPerpetual)\\n    {\\n        for (uint256 i = 0; i < _traderVault.subVaults.length; i++) {\\n            positionPerpetual = positionPerpetual\\n                .add(_traderVault.subVaults[i].positionPerpetuals[_productId])\\n                .toInt128();\\n        }\\n    }\\n\\n    /**\\n     * @notice Updates positions in the vault\\n     * @param _traderVault trader vault object\\n     * @param _subVaultIndex index of sub-vault\\n     * @param _productId product id\\n     * @param _positionPerpetual amount of position to increase or decrease\\n     * @param _tradePrice trade price\\n     * @param _fundingFeePerPosition entry funding fee paid per position\\n     */\\n    function updateVault(\\n        TraderVault storage _traderVault,\\n        uint256 _subVaultIndex,\\n        uint256 _productId,\\n        int128 _positionPerpetual,\\n        uint256 _tradePrice,\\n        int256 _fundingFeePerPosition\\n    ) external returns (int256 deltaUsdcPosition) {\\n        require(!_traderVault.isInsolvent, \\\"T2\\\");\\n        require(_positionPerpetual != 0, \\\"T4\\\");\\n\\n        if (_traderVault.subVaults.length == _subVaultIndex) {\\n            int128[2] memory positionPerpetuals;\\n            uint128[2] memory entryPrices;\\n            int128[2] memory entryFundingFee;\\n\\n            _traderVault.subVaults.push(SubVault(positionPerpetuals, entryPrices, entryFundingFee));\\n        } else {\\n            require(_traderVault.subVaults.length > _subVaultIndex, \\\"T3\\\");\\n        }\\n\\n        SubVault storage subVault = _traderVault.subVaults[_subVaultIndex];\\n\\n        {\\n            (int256 newEntryPrice, int256 profitValue) = EntryPriceMath.updateEntryPrice(\\n                int256(subVault.entryPrices[_productId]),\\n                subVault.positionPerpetuals[_productId],\\n                int256(_tradePrice),\\n                _positionPerpetual\\n            );\\n\\n            subVault.entryPrices[_productId] = newEntryPrice.toUint256().toUint128();\\n            deltaUsdcPosition = deltaUsdcPosition.add(profitValue);\\n        }\\n\\n        {\\n            (int256 newEntryFundingFee, int256 profitValue) = EntryPriceMath.updateEntryPrice(\\n                int256(subVault.entryFundingFee[_productId]),\\n                subVault.positionPerpetuals[_productId],\\n                _fundingFeePerPosition,\\n                _positionPerpetual\\n            );\\n\\n            subVault.entryFundingFee[_productId] = newEntryFundingFee.toInt128();\\n            deltaUsdcPosition = deltaUsdcPosition.sub(profitValue);\\n        }\\n\\n        _traderVault.positionUsdc = _traderVault.positionUsdc.add(deltaUsdcPosition).toInt128();\\n\\n        subVault.positionPerpetuals[_productId] = subVault\\n            .positionPerpetuals[_productId]\\n            .add(_positionPerpetual)\\n            .toInt128();\\n    }\\n\\n    /**\\n     * @notice Checks the vault is liquidatable and return result\\n     * if PositionValue is less than MinCollateral return true\\n     * otherwise return false\\n     * @param _traderVault trader vault object\\n     * @return if true the vault is liquidatable, if false the vault is not liquidatable\\n     */\\n    function checkVaultIsLiquidatable(\\n        TraderVault memory _traderVault,\\n        IPerpetualMarketCore.TradePriceInfo memory _tradePriceInfo\\n    ) internal pure returns (bool) {\\n        int256 positionValue = getPositionValue(_traderVault, _tradePriceInfo);\\n\\n        return positionValue < getMinCollateral(_traderVault, _tradePriceInfo);\\n    }\\n\\n    /**\\n     * @notice Set insolvency flag if needed\\n     * If PositionValue is negative, set insolvency flag.\\n     * @param _traderVault trader vault object\\n     */\\n    function setInsolvencyFlagIfNeeded(TraderVault storage _traderVault) external {\\n        // Confirm that there are no positions\\n        for (uint256 i = 0; i < _traderVault.subVaults.length; i++) {\\n            for (uint256 j = 0; j < MAX_PRODUCT_ID; j++) {\\n                require(_traderVault.subVaults[i].positionPerpetuals[j] == 0);\\n            }\\n        }\\n\\n        // If there are no positions, PositionUSDC is equal to PositionValue.\\n        if (_traderVault.positionUsdc < 0) {\\n            _traderVault.isInsolvent = true;\\n        }\\n    }\\n\\n    /**\\n     * @notice Decreases liquidation reward from usdc position\\n     * @param _traderVault trader vault object\\n     * @param _minCollateral min collateral\\n     * @param _liquidationFee liquidation fee rate\\n     */\\n    function decreaseLiquidationReward(\\n        TraderVault storage _traderVault,\\n        int256 _minCollateral,\\n        int256 _liquidationFee\\n    ) external returns (uint256) {\\n        if (_traderVault.positionUsdc <= 0) {\\n            return 0;\\n        }\\n\\n        int256 reward = _minCollateral.mul(_liquidationFee).div(1e4);\\n\\n        reward = Math.min(reward, _traderVault.positionUsdc);\\n\\n        // reduce margin\\n        // sub is safe because we know reward is less than positionUsdc\\n        _traderVault.positionUsdc -= reward.toInt128();\\n\\n        return reward.toUint256();\\n    }\\n\\n    /**\\n     * @notice Gets min collateral of the vault\\n     * @param _traderVault trader vault object\\n     * @param _tradePriceInfo trade price info\\n     * @return MinCollateral scaled by 1e8\\n     */\\n    function getMinCollateral(\\n        TraderVault memory _traderVault,\\n        IPerpetualMarketCore.TradePriceInfo memory _tradePriceInfo\\n    ) internal pure returns (int256) {\\n        int128[2] memory assetAmounts = getPositionPerpetuals(_traderVault);\\n\\n        return calculateMinCollateral(assetAmounts, _tradePriceInfo);\\n    }\\n\\n    /**\\n     * @notice Calculates min collateral\\n     * MinCollateral = alpha*S*(|2*S*(1+fundingSqueeth)*PositionSqueeth + (1+fundingFuture)*PositionFuture| + 2*alpha*S*(1+fundingSqueeth)*|PositionSqueeth|)\\n     * where alpha is 0.05\\n     * @param positionPerpetuals amount of perpetual positions\\n     * @param _tradePriceInfo trade price info\\n     * @return MinCollateral scaled by 1e8\\n     */\\n    function calculateMinCollateral(\\n        int128[2] memory positionPerpetuals,\\n        IPerpetualMarketCore.TradePriceInfo memory _tradePriceInfo\\n    ) internal pure returns (int256) {\\n        // priceWithFunding = S*(1+fundingSqueeth)\\n        int256 priceWithFunding = int256(_tradePriceInfo.spotPrice).mul(_tradePriceInfo.fundingRates[1].add(1e16)).div(\\n            1e8\\n        );\\n\\n        uint256 maxDelta = Math.abs(\\n            (priceWithFunding.mul(positionPerpetuals[1]).mul(2).div(1e20)).add(\\n                positionPerpetuals[0].mul(_tradePriceInfo.fundingRates[0].add(1e16)).div(1e16)\\n            )\\n        );\\n\\n        maxDelta = maxDelta.add(\\n            Math.abs(int256(RISK_PARAM_FOR_VAULT).mul(priceWithFunding).mul(2).mul(positionPerpetuals[1]).div(1e24))\\n        );\\n\\n        uint256 minCollateral = (RISK_PARAM_FOR_VAULT.mul(_tradePriceInfo.spotPrice).mul(maxDelta)) / 1e12;\\n\\n        if ((positionPerpetuals[0] != 0 || positionPerpetuals[1] != 0) && minCollateral < MIN_MARGIN) {\\n            minCollateral = MIN_MARGIN;\\n        }\\n\\n        return minCollateral.toInt256();\\n    }\\n\\n    /**\\n     * @notice Gets position value in the vault\\n     * PositionValue = USDC + \\u03a3(ValueOfSubVault_i)\\n     * @param _traderVault trader vault object\\n     * @param _tradePriceInfo trade price info\\n     * @return PositionValue scaled by 1e8\\n     */\\n    function getPositionValue(\\n        TraderVault memory _traderVault,\\n        IPerpetualMarketCore.TradePriceInfo memory _tradePriceInfo\\n    ) internal pure returns (int256) {\\n        int256 value = _traderVault.positionUsdc;\\n\\n        for (uint256 i = 0; i < _traderVault.subVaults.length; i++) {\\n            value = value.add(getSubVaultPositionValue(_traderVault.subVaults[i], _tradePriceInfo));\\n        }\\n\\n        return value;\\n    }\\n\\n    /**\\n     * @notice Gets position value in the sub-vault\\n     * ValueOfSubVault = TotalPerpetualValueOfSubVault + TotalFundingFeePaidOfSubVault\\n     * @param _subVault sub-vault object\\n     * @param _tradePriceInfo trade price info\\n     * @return ValueOfSubVault scaled by 1e8\\n     */\\n    function getSubVaultPositionValue(\\n        SubVault memory _subVault,\\n        IPerpetualMarketCore.TradePriceInfo memory _tradePriceInfo\\n    ) internal pure returns (int256) {\\n        return\\n            getTotalPerpetualValueOfSubVault(_subVault, _tradePriceInfo).add(\\n                getTotalFundingFeePaidOfSubVault(_subVault, _tradePriceInfo.amountsFundingPaidPerPosition)\\n            );\\n    }\\n\\n    /**\\n     * @notice Gets total perpetual value in the sub-vault\\n     * TotalPerpetualValueOfSubVault = \\u03a3(PerpetualValueOfSubVault_i)\\n     * @param _subVault sub-vault object\\n     * @param _tradePriceInfo trade price info\\n     * @return TotalPerpetualValueOfSubVault scaled by 1e8\\n     */\\n    function getTotalPerpetualValueOfSubVault(\\n        SubVault memory _subVault,\\n        IPerpetualMarketCore.TradePriceInfo memory _tradePriceInfo\\n    ) internal pure returns (int256) {\\n        int256 pnl;\\n\\n        for (uint256 i = 0; i < MAX_PRODUCT_ID; i++) {\\n            pnl = pnl.add(getPerpetualValueOfSubVault(_subVault, i, _tradePriceInfo));\\n        }\\n\\n        return pnl;\\n    }\\n\\n    /**\\n     * @notice Gets perpetual value in the sub-vault\\n     * PerpetualValueOfSubVault_i = (TradePrice_i - EntryPrice_i)*Position_i\\n     * @param _subVault sub-vault object\\n     * @param _productId product id\\n     * @param _tradePriceInfo trade price info\\n     * @return PerpetualValueOfSubVault_i scaled by 1e8\\n     */\\n    function getPerpetualValueOfSubVault(\\n        SubVault memory _subVault,\\n        uint256 _productId,\\n        IPerpetualMarketCore.TradePriceInfo memory _tradePriceInfo\\n    ) internal pure returns (int256) {\\n        int256 pnl = _tradePriceInfo.tradePrices[_productId].sub(_subVault.entryPrices[_productId].toInt256()).mul(\\n            _subVault.positionPerpetuals[_productId]\\n        );\\n\\n        return pnl / 1e8;\\n    }\\n\\n    /**\\n     * @notice Gets total funding fee in the sub-vault\\n     * TotalFundingFeePaidOfSubVault = \\u03a3(FundingFeePaidOfSubVault_i)\\n     * @param _subVault sub-vault object\\n     * @param _amountsFundingPaidPerPosition the cumulative funding fee paid by long per position\\n     * @return TotalFundingFeePaidOfSubVault scaled by 1e8\\n     */\\n    function getTotalFundingFeePaidOfSubVault(\\n        SubVault memory _subVault,\\n        int128[2] memory _amountsFundingPaidPerPosition\\n    ) internal pure returns (int256) {\\n        int256 fundingFee;\\n\\n        for (uint256 i = 0; i < MAX_PRODUCT_ID; i++) {\\n            fundingFee = fundingFee.add(getFundingFeePaidOfSubVault(_subVault, i, _amountsFundingPaidPerPosition));\\n        }\\n\\n        return fundingFee;\\n    }\\n\\n    /**\\n     * @notice Gets funding fee in the sub-vault\\n     * FundingFeePaidOfSubVault_i = Position_i*(EntryFundingFee_i - FundingFeeGlobal_i)\\n     * @param _subVault sub-vault object\\n     * @param _productId product id\\n     * @param _amountsFundingPaidPerPosition cumulative funding fee paid by long per position.\\n     * @return FundingFeePaidOfSubVault_i scaled by 1e8\\n     */\\n    function getFundingFeePaidOfSubVault(\\n        SubVault memory _subVault,\\n        uint256 _productId,\\n        int128[2] memory _amountsFundingPaidPerPosition\\n    ) internal pure returns (int256) {\\n        int256 fundingFee = _subVault.entryFundingFee[_productId].sub(_amountsFundingPaidPerPosition[_productId]).mul(\\n            _subVault.positionPerpetuals[_productId]\\n        );\\n\\n        return fundingFee / 1e8;\\n    }\\n}\\n\",\"keccak256\":\"0xc8641fabfa83b9e265fe027165989c826067b93e61996764067d066cf74e030d\",\"license\":\"agpl-3.0\"}},\"version\":1}",
  "bytecode": "0x611adc610026600b82828239805160001a60731461001957fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100615760003560e01c80631bc0458214610066578063652aa4831461008857806369e2bed0146100be578063a8ffb3b9146100de578063e69e266d146100fe575b600080fd5b81801561007257600080fd5b506100866100813660046117b1565b61011e565b005b81801561009457600080fd5b506100a86100a33660046117ea565b6101c3565b6040516100b59190611914565b60405180910390f35b8180156100ca57600080fd5b506100866100d93660046117c9565b610251565b8180156100ea57600080fd5b506100a86100f93660046118c4565b6102df565b81801561010a57600080fd5b506100a8610119366004611815565b610676565b60005b600182015481101561019d5760005b60028110156101945782600101828154811061014857fe5b9060005260206000209060030201600001816002811061016457fe5b600291828204019190066010029054906101000a9004600f0b600f0b60001461018c57600080fd5b600101610130565b50600101610121565b5080546000600f91820b90910b12156101c05760028101805460ff191660011790555b50565b8254600090600f90810b900b81126101dd5750600061024a565b60006101f56127106101ef8686610c1f565b90610cd1565b855490915061020c908290600f90810b900b610d89565b905061021781610d9e565b8554600f81810b9290920390910b6001600160801b03166001600160801b031990911617855561024681610e07565b9150505b9392505050565b600282015460ff161561027f5760405162461bcd60e51b815260040161027690611955565b60405180910390fd5b6000811361029f5760405162461bcd60e51b81526004016102769061198d565b81546102bb906102b690600f90810b900b83610e5e565b610d9e565b8254600f9190910b6001600160801b03166001600160801b03199091161790915550565b600286015460009060ff16156103075760405162461bcd60e51b815260040161027690611955565b83600f0b6000141561032b5760405162461bcd60e51b81526004016102769061191d565b60018701548614156103cc5761033f611589565b610347611589565b61034f611589565b6040805160608101825284815260208082018590529181018390526001808d018054918201815560009081529290922081519192600302019061039590829060026115a7565b5060208201516103ab906001830190600261164f565b5060408201516103c190600280840191906115a7565b5050505050506103ef565b600187015486106103ef5760405162461bcd60e51b815260040161027690611971565b600087600101878154811061040057fe5b9060005260206000209060030201905060008061048283600101896002811061042557fe5b600291828204019190066010029054906101000a90046001600160801b03166001600160801b0316846000018a6002811061045c57fe5b600291828204019190066010029054906101000a9004600f0b600f0b888a600f0b610ec3565b9150915061049761049283610e07565b610ffb565b8360010189600281106104a657fe5b600291828204019190066010026101000a8154816001600160801b0302191690836001600160801b031602179055506104e88185610e5e90919063ffffffff16565b9350505060008061055283600201896002811061050157fe5b600291828204019190066010029054906101000a9004600f0b600f0b846000018a6002811061052c57fe5b600291828204019190066010029054906101000a9004600f0b600f0b878a600f0b610ec3565b9150915061055f82610d9e565b83600201896002811061056e57fe5b600291828204019190066010026101000a8154816001600160801b030219169083600f0b6001600160801b031602179055506105b3818561103f90919063ffffffff16565b8a549094506105cf92506102b69150600f90810b900b84610e5e565b88546001600160801b0319166001600160801b03600f92830b1617895561062d906102b69087900b83896002811061060357fe5b600291828204019190066010029054906101000a9004600f0b600f0b610e5e90919063ffffffff16565b81876002811061063957fe5b600291828204019190066010026101000a8154816001600160801b030219169083600f0b6001600160801b03160217905550509695505050505050565b6002830154829060ff161561069d5760405162461bcd60e51b815260040161027690611955565b604080516060810182528554600f90810b810b900b8152600186018054835160208281028201810190955281815260009461084594938a938286019392889084015b82821015610826576000848152602090206040805160a0810190915290600384020181606081018260028282826020028201916000905b82829054906101000a9004600f0b600f0b81526020019060100190602082600f01049283019260010382029150808411610716575050509284525050604080518082019182905260209093019291506001840190600290826000855b82829054906101000a90046001600160801b03166001600160801b031681526020019060100190602082600f0104928301926001038202915080841161077257505050928452505060408051808201918290526020909301929150600284810191826000855b82829054906101000a9004600f0b600f0b81526020019060100190602082600f010492830192600103820291508084116107d8579050505050505081525050815260200190600101906106df565b505050908252506002919091015460ff161515602090910152846110a4565b604080516060810182528754600f90810b810b900b815260018801805483516020828102820181019095528181529495506000946109f0948b93818601939091889084015b828210156109d1576000848152602090206040805160a0810190915290600384020181606081018260028282826020028201916000905b82829054906101000a9004600f0b600f0b81526020019060100190602082600f010492830192600103820291508084116108c1575050509284525050604080518082019182905260209093019291506001840190600290826000855b82829054906101000a90046001600160801b03166001600160801b031681526020019060100190602082600f0104928301926001038202915080841161091d57505050928452505060408051808201918290526020909301929150600284810191826000855b82829054906101000a9004600f0b600f0b81526020019060100190602082600f010492830192600103820291508084116109835790505050505050815250508152602001906001019061088a565b505050908252506002919091015460ff161515602090910152856110f8565b9050808203600081900386128015610a085750600081135b8015610a145750600086125b15610a20578060000393505b8654610a37906102b690600f90810b900b86610e5e565b87546001600160801b0319166001600160801b03600f92830b16178089556040805160608101825291830b830b90920b81526001890180548351602080830282018101909552818152610bf8948c9381860193909160009084015b82821015610bd9576000848152602090206040805160a0810190915290600384020181606081018260028282826020028201916000905b82829054906101000a9004600f0b600f0b81526020019060100190602082600f01049283019260010382029150808411610ac9575050509284525050604080518082019182905260209093019291506001840190600290826000855b82829054906101000a90046001600160801b03166001600160801b031681526020019060100190602082600f01049283019260010382029150808411610b2557505050928452505060408051808201918290526020909301929150600284810191826000855b82829054906101000a9004600f0b600f0b81526020019060100190602082600f01049283019260010382029150808411610b8b57905050505050508152505081526020019060010190610a92565b505050908252506002919091015460ff16151560209091015286611118565b15610c155760405162461bcd60e51b815260040161027690611939565b5050509392505050565b600082610c2e57506000610ccb565b82600019148015610c425750600160ff1b82145b15610c7e5760405162461bcd60e51b8152600401808060200182810382526027815260200180611a346027913960400191505060405180910390fd5b82820282848281610c8b57fe5b0514610cc85760405162461bcd60e51b8152600401808060200182810382526027815260200180611a346027913960400191505060405180910390fd5b90505b92915050565b600081610d25576040805162461bcd60e51b815260206004820181905260248201527f5369676e6564536166654d6174683a206469766973696f6e206279207a65726f604482015290519081900360640190fd5b81600019148015610d395750600160ff1b83145b15610d755760405162461bcd60e51b81526004018080602001828103825260218152602001806119f26021913960400191505060405180910390fd5b6000828481610d8057fe5b05949350505050565b6000818313610d985782610cc8565b50919050565b60006f7fffffffffffffffffffffffffffffff198212158015610dc457506001607f1b82125b610dff5760405162461bcd60e51b81526004018080602001828103825260278152602001806119aa6027913960400191505060405180910390fd5b50805b919050565b600080821215610dff576040805162461bcd60e51b815260206004820181905260248201527f53616665436173743a2076616c7565206d75737420626520706f736974697665604482015290519081900360640190fd5b6000828201818312801590610e735750838112155b80610e885750600083128015610e8857508381125b610cc85760405162461bcd60e51b81526004018080602001828103825260218152602001806119d16021913960400191505060405180910390fd5b60008080610ed18685610e5e565b9050851580610eeb5750600086138015610eeb5750600084135b80610f015750600086128015610f015750600084125b15610f5157610f4a610f1b610f168887610e5e565b611139565b6101ef610f31610f2a88611139565b8990610c1f565b610f44610f3d8b611139565b8c90610c1f565b90610e5e565b9250610ff1565b600086138015610f615750600084125b8015610f6d5750600081135b80610f8f5750600086128015610f835750600084135b8015610f8f5750600081125b15610fc3578692506305f5e100610fb4610fa9878661103f565b600087900390610c1f565b81610fbb57fe5b059150610ff1565b8015610fcd578492505b6305f5e100610fe6610fdf878a61103f565b8890610c1f565b81610fed57fe5b0591505b5094509492505050565b6000600160801b8210610dff5760405162461bcd60e51b81526004018080602001828103825260278152602001806119aa6027913960400191505060405180910390fd5b60008183038183128015906110545750838113155b80611069575060008312801561106957508381135b610cc85760405162461bcd60e51b8152600401808060200182810382526024815260200180611a836024913960400191505060405180910390fd5b8151600090600f0b815b8460200151518110156110f0576110e66110df866020015183815181106110d157fe5b60200260200101518661114a565b8390610e5e565b91506001016110ae565b509392505050565b60008061110484611167565b905061111081846111a8565b949350505050565b60008061112584846110a4565b905061113184846110f8565b139392505050565b600080821215610dff575060000390565b6000610cc861115d84846060015161131e565b610f448585611345565b61116f611589565b60005b6002811015610d9857611185838261136c565b82826002811061119157fe5b600f92830b90920b60209092020152600101611172565b6000806111ee6305f5e1006101ef6111dd662386f26fc1000087604001516001600281106111d257fe5b602002015190610e5e565b86516001600160801b031690610c1f565b9050600061125a610f1661122d662386f26fc100006101ef611222662386f26fc100008a604001516000600281106111d257fe5b8a51600f0b90610c1f565b610f4468056bc75e2d631000006101ef60026112548c600160200201518a90600f0b610c1f565b90610c1f565b905061129461128d610f1669d3c21bcecceda10000006101ef8960016020020151600f0b6112546002816101f48b610c1f565b82906113cd565b9050600064e8d4a510006112ca836112c488600001516001600160801b03166101f461142790919063ffffffff16565b90611427565b816112d157fe5b87519190049150600f0b1515806112ee57506020860151600f0b15155b80156112fe5750640ba43b740081105b1561130b5750640ba43b74005b61131481611480565b9695505050505050565b60008060005b60028110156110f05761133b6110df8683876114c4565b9150600101611324565b60008060005b60028110156110f0576113626110df868387611527565b915060010161134b565b6000805b8360200151518110156113c6576113bc6102b68560200151838151811061139357fe5b60200260200101516000015185600281106113aa57fe5b6020020151600f85810b91900b610e5e565b9150600101611370565b5092915050565b600082820183811015610cc8576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b60008261143657506000610ccb565b8282028284828161144357fe5b0414610cc85760405162461bcd60e51b8152600401808060200182810382526021815260200180611a136021913960400191505060405180910390fd5b6000600160ff1b8210610dff5760405162461bcd60e51b8152600401808060200182810382526028815260200180611a5b6028913960400191505060405180910390fd5b600080611517856000015185600281106114da57fe5b6020020151600f0b6112548587600281106114f157fe5b6020020151600f0b8860400151886002811061150957fe5b6020020151600f0b9061103f565b6305f5e100900595945050505050565b6000806115178560000151856002811061153d57fe5b6020020151600f0b61125461156e8860200151886002811061155b57fe5b60200201516001600160801b0316611480565b8660200151886002811061157e57fe5b60200201519061103f565b60405180604001604052806002906020820280368337509192915050565b60018301918390821561163f5791602002820160005b8382111561160a57835183826101000a8154816001600160801b030219169083600f0b6001600160801b031602179055509260200192601001602081600f010492830192600103026115bd565b801561163d5782816101000a8154906001600160801b030219169055601001602081600f0104928301926001030261160a565b505b5061164b9291506116af565b5090565b60018301918390821561163f5791602002820160005b8382111561160a57835183826101000a8154816001600160801b0302191690836001600160801b031602179055509260200192601001602081600f01049283019260010302611665565b5b8082111561164b57600081556001016116b0565b600082601f8301126116d4578081fd5b6040516040810181811067ffffffffffffffff821117156116f157fe5b8060405250808385604086011115611707578384fd5b835b60028110156117305761171b8261179f565b83526020928301929190910190600101611709565b509195945050505050565b600082601f83011261174b578081fd5b6040516040810181811067ffffffffffffffff8211171561176857fe5b806040525080838560408601111561177e578384fd5b835b6002811015611730578135835260209283019290910190600101611780565b8035600f81900b8114610e0257600080fd5b6000602082840312156117c2578081fd5b5035919050565b600080604083850312156117db578081fd5b50508035926020909101359150565b6000806000606084860312156117fe578081fd5b505081359360208301359350604090920135919050565b600080600083850361012081121561182b578384fd5b843593506020850135925060e0603f1982011215611847578182fd5b506040516080810181811067ffffffffffffffff8211171561186557fe5b60409081528501356001600160801b0381168114611881578283fd5b8152611890866060870161173b565b60208201526118a28660a0870161173b565b60408201526118b48660e087016116c4565b6060820152809150509250925092565b60008060008060008060c087890312156118dc578182fd5b8635955060208701359450604087013593506118fa6060880161179f565b92506080870135915060a087013590509295509295509295565b90815260200190565b602080825260029082015261150d60f21b604082015260600190565b602080825260029082015261054360f41b604082015260600190565b6020808252600290820152612a1960f11b604082015260600190565b602080825260029082015261543360f01b604082015260600190565b602080825260029082015261543560f01b60408201526060019056fe53616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974735369676e6564536166654d6174683a206164646974696f6e206f766572666c6f775369676e6564536166654d6174683a206469766973696f6e206f766572666c6f77536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f775369676e6564536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f7753616665436173743a2076616c756520646f65736e27742066697420696e20616e20696e743235365369676e6564536166654d6174683a207375627472616374696f6e206f766572666c6f77a264697066735822122038b27c8d03240b3121fccc5d232fd6d9190106e907541b35522546914495cfcf64736f6c63430007060033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100615760003560e01c80631bc0458214610066578063652aa4831461008857806369e2bed0146100be578063a8ffb3b9146100de578063e69e266d146100fe575b600080fd5b81801561007257600080fd5b506100866100813660046117b1565b61011e565b005b81801561009457600080fd5b506100a86100a33660046117ea565b6101c3565b6040516100b59190611914565b60405180910390f35b8180156100ca57600080fd5b506100866100d93660046117c9565b610251565b8180156100ea57600080fd5b506100a86100f93660046118c4565b6102df565b81801561010a57600080fd5b506100a8610119366004611815565b610676565b60005b600182015481101561019d5760005b60028110156101945782600101828154811061014857fe5b9060005260206000209060030201600001816002811061016457fe5b600291828204019190066010029054906101000a9004600f0b600f0b60001461018c57600080fd5b600101610130565b50600101610121565b5080546000600f91820b90910b12156101c05760028101805460ff191660011790555b50565b8254600090600f90810b900b81126101dd5750600061024a565b60006101f56127106101ef8686610c1f565b90610cd1565b855490915061020c908290600f90810b900b610d89565b905061021781610d9e565b8554600f81810b9290920390910b6001600160801b03166001600160801b031990911617855561024681610e07565b9150505b9392505050565b600282015460ff161561027f5760405162461bcd60e51b815260040161027690611955565b60405180910390fd5b6000811361029f5760405162461bcd60e51b81526004016102769061198d565b81546102bb906102b690600f90810b900b83610e5e565b610d9e565b8254600f9190910b6001600160801b03166001600160801b03199091161790915550565b600286015460009060ff16156103075760405162461bcd60e51b815260040161027690611955565b83600f0b6000141561032b5760405162461bcd60e51b81526004016102769061191d565b60018701548614156103cc5761033f611589565b610347611589565b61034f611589565b6040805160608101825284815260208082018590529181018390526001808d018054918201815560009081529290922081519192600302019061039590829060026115a7565b5060208201516103ab906001830190600261164f565b5060408201516103c190600280840191906115a7565b5050505050506103ef565b600187015486106103ef5760405162461bcd60e51b815260040161027690611971565b600087600101878154811061040057fe5b9060005260206000209060030201905060008061048283600101896002811061042557fe5b600291828204019190066010029054906101000a90046001600160801b03166001600160801b0316846000018a6002811061045c57fe5b600291828204019190066010029054906101000a9004600f0b600f0b888a600f0b610ec3565b9150915061049761049283610e07565b610ffb565b8360010189600281106104a657fe5b600291828204019190066010026101000a8154816001600160801b0302191690836001600160801b031602179055506104e88185610e5e90919063ffffffff16565b9350505060008061055283600201896002811061050157fe5b600291828204019190066010029054906101000a9004600f0b600f0b846000018a6002811061052c57fe5b600291828204019190066010029054906101000a9004600f0b600f0b878a600f0b610ec3565b9150915061055f82610d9e565b83600201896002811061056e57fe5b600291828204019190066010026101000a8154816001600160801b030219169083600f0b6001600160801b031602179055506105b3818561103f90919063ffffffff16565b8a549094506105cf92506102b69150600f90810b900b84610e5e565b88546001600160801b0319166001600160801b03600f92830b1617895561062d906102b69087900b83896002811061060357fe5b600291828204019190066010029054906101000a9004600f0b600f0b610e5e90919063ffffffff16565b81876002811061063957fe5b600291828204019190066010026101000a8154816001600160801b030219169083600f0b6001600160801b03160217905550509695505050505050565b6002830154829060ff161561069d5760405162461bcd60e51b815260040161027690611955565b604080516060810182528554600f90810b810b900b8152600186018054835160208281028201810190955281815260009461084594938a938286019392889084015b82821015610826576000848152602090206040805160a0810190915290600384020181606081018260028282826020028201916000905b82829054906101000a9004600f0b600f0b81526020019060100190602082600f01049283019260010382029150808411610716575050509284525050604080518082019182905260209093019291506001840190600290826000855b82829054906101000a90046001600160801b03166001600160801b031681526020019060100190602082600f0104928301926001038202915080841161077257505050928452505060408051808201918290526020909301929150600284810191826000855b82829054906101000a9004600f0b600f0b81526020019060100190602082600f010492830192600103820291508084116107d8579050505050505081525050815260200190600101906106df565b505050908252506002919091015460ff161515602090910152846110a4565b604080516060810182528754600f90810b810b900b815260018801805483516020828102820181019095528181529495506000946109f0948b93818601939091889084015b828210156109d1576000848152602090206040805160a0810190915290600384020181606081018260028282826020028201916000905b82829054906101000a9004600f0b600f0b81526020019060100190602082600f010492830192600103820291508084116108c1575050509284525050604080518082019182905260209093019291506001840190600290826000855b82829054906101000a90046001600160801b03166001600160801b031681526020019060100190602082600f0104928301926001038202915080841161091d57505050928452505060408051808201918290526020909301929150600284810191826000855b82829054906101000a9004600f0b600f0b81526020019060100190602082600f010492830192600103820291508084116109835790505050505050815250508152602001906001019061088a565b505050908252506002919091015460ff161515602090910152856110f8565b9050808203600081900386128015610a085750600081135b8015610a145750600086125b15610a20578060000393505b8654610a37906102b690600f90810b900b86610e5e565b87546001600160801b0319166001600160801b03600f92830b16178089556040805160608101825291830b830b90920b81526001890180548351602080830282018101909552818152610bf8948c9381860193909160009084015b82821015610bd9576000848152602090206040805160a0810190915290600384020181606081018260028282826020028201916000905b82829054906101000a9004600f0b600f0b81526020019060100190602082600f01049283019260010382029150808411610ac9575050509284525050604080518082019182905260209093019291506001840190600290826000855b82829054906101000a90046001600160801b03166001600160801b031681526020019060100190602082600f01049283019260010382029150808411610b2557505050928452505060408051808201918290526020909301929150600284810191826000855b82829054906101000a9004600f0b600f0b81526020019060100190602082600f01049283019260010382029150808411610b8b57905050505050508152505081526020019060010190610a92565b505050908252506002919091015460ff16151560209091015286611118565b15610c155760405162461bcd60e51b815260040161027690611939565b5050509392505050565b600082610c2e57506000610ccb565b82600019148015610c425750600160ff1b82145b15610c7e5760405162461bcd60e51b8152600401808060200182810382526027815260200180611a346027913960400191505060405180910390fd5b82820282848281610c8b57fe5b0514610cc85760405162461bcd60e51b8152600401808060200182810382526027815260200180611a346027913960400191505060405180910390fd5b90505b92915050565b600081610d25576040805162461bcd60e51b815260206004820181905260248201527f5369676e6564536166654d6174683a206469766973696f6e206279207a65726f604482015290519081900360640190fd5b81600019148015610d395750600160ff1b83145b15610d755760405162461bcd60e51b81526004018080602001828103825260218152602001806119f26021913960400191505060405180910390fd5b6000828481610d8057fe5b05949350505050565b6000818313610d985782610cc8565b50919050565b60006f7fffffffffffffffffffffffffffffff198212158015610dc457506001607f1b82125b610dff5760405162461bcd60e51b81526004018080602001828103825260278152602001806119aa6027913960400191505060405180910390fd5b50805b919050565b600080821215610dff576040805162461bcd60e51b815260206004820181905260248201527f53616665436173743a2076616c7565206d75737420626520706f736974697665604482015290519081900360640190fd5b6000828201818312801590610e735750838112155b80610e885750600083128015610e8857508381125b610cc85760405162461bcd60e51b81526004018080602001828103825260218152602001806119d16021913960400191505060405180910390fd5b60008080610ed18685610e5e565b9050851580610eeb5750600086138015610eeb5750600084135b80610f015750600086128015610f015750600084125b15610f5157610f4a610f1b610f168887610e5e565b611139565b6101ef610f31610f2a88611139565b8990610c1f565b610f44610f3d8b611139565b8c90610c1f565b90610e5e565b9250610ff1565b600086138015610f615750600084125b8015610f6d5750600081135b80610f8f5750600086128015610f835750600084135b8015610f8f5750600081125b15610fc3578692506305f5e100610fb4610fa9878661103f565b600087900390610c1f565b81610fbb57fe5b059150610ff1565b8015610fcd578492505b6305f5e100610fe6610fdf878a61103f565b8890610c1f565b81610fed57fe5b0591505b5094509492505050565b6000600160801b8210610dff5760405162461bcd60e51b81526004018080602001828103825260278152602001806119aa6027913960400191505060405180910390fd5b60008183038183128015906110545750838113155b80611069575060008312801561106957508381135b610cc85760405162461bcd60e51b8152600401808060200182810382526024815260200180611a836024913960400191505060405180910390fd5b8151600090600f0b815b8460200151518110156110f0576110e66110df866020015183815181106110d157fe5b60200260200101518661114a565b8390610e5e565b91506001016110ae565b509392505050565b60008061110484611167565b905061111081846111a8565b949350505050565b60008061112584846110a4565b905061113184846110f8565b139392505050565b600080821215610dff575060000390565b6000610cc861115d84846060015161131e565b610f448585611345565b61116f611589565b60005b6002811015610d9857611185838261136c565b82826002811061119157fe5b600f92830b90920b60209092020152600101611172565b6000806111ee6305f5e1006101ef6111dd662386f26fc1000087604001516001600281106111d257fe5b602002015190610e5e565b86516001600160801b031690610c1f565b9050600061125a610f1661122d662386f26fc100006101ef611222662386f26fc100008a604001516000600281106111d257fe5b8a51600f0b90610c1f565b610f4468056bc75e2d631000006101ef60026112548c600160200201518a90600f0b610c1f565b90610c1f565b905061129461128d610f1669d3c21bcecceda10000006101ef8960016020020151600f0b6112546002816101f48b610c1f565b82906113cd565b9050600064e8d4a510006112ca836112c488600001516001600160801b03166101f461142790919063ffffffff16565b90611427565b816112d157fe5b87519190049150600f0b1515806112ee57506020860151600f0b15155b80156112fe5750640ba43b740081105b1561130b5750640ba43b74005b61131481611480565b9695505050505050565b60008060005b60028110156110f05761133b6110df8683876114c4565b9150600101611324565b60008060005b60028110156110f0576113626110df868387611527565b915060010161134b565b6000805b8360200151518110156113c6576113bc6102b68560200151838151811061139357fe5b60200260200101516000015185600281106113aa57fe5b6020020151600f85810b91900b610e5e565b9150600101611370565b5092915050565b600082820183811015610cc8576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b60008261143657506000610ccb565b8282028284828161144357fe5b0414610cc85760405162461bcd60e51b8152600401808060200182810382526021815260200180611a136021913960400191505060405180910390fd5b6000600160ff1b8210610dff5760405162461bcd60e51b8152600401808060200182810382526028815260200180611a5b6028913960400191505060405180910390fd5b600080611517856000015185600281106114da57fe5b6020020151600f0b6112548587600281106114f157fe5b6020020151600f0b8860400151886002811061150957fe5b6020020151600f0b9061103f565b6305f5e100900595945050505050565b6000806115178560000151856002811061153d57fe5b6020020151600f0b61125461156e8860200151886002811061155b57fe5b60200201516001600160801b0316611480565b8660200151886002811061157e57fe5b60200201519061103f565b60405180604001604052806002906020820280368337509192915050565b60018301918390821561163f5791602002820160005b8382111561160a57835183826101000a8154816001600160801b030219169083600f0b6001600160801b031602179055509260200192601001602081600f010492830192600103026115bd565b801561163d5782816101000a8154906001600160801b030219169055601001602081600f0104928301926001030261160a565b505b5061164b9291506116af565b5090565b60018301918390821561163f5791602002820160005b8382111561160a57835183826101000a8154816001600160801b0302191690836001600160801b031602179055509260200192601001602081600f01049283019260010302611665565b5b8082111561164b57600081556001016116b0565b600082601f8301126116d4578081fd5b6040516040810181811067ffffffffffffffff821117156116f157fe5b8060405250808385604086011115611707578384fd5b835b60028110156117305761171b8261179f565b83526020928301929190910190600101611709565b509195945050505050565b600082601f83011261174b578081fd5b6040516040810181811067ffffffffffffffff8211171561176857fe5b806040525080838560408601111561177e578384fd5b835b6002811015611730578135835260209283019290910190600101611780565b8035600f81900b8114610e0257600080fd5b6000602082840312156117c2578081fd5b5035919050565b600080604083850312156117db578081fd5b50508035926020909101359150565b6000806000606084860312156117fe578081fd5b505081359360208301359350604090920135919050565b600080600083850361012081121561182b578384fd5b843593506020850135925060e0603f1982011215611847578182fd5b506040516080810181811067ffffffffffffffff8211171561186557fe5b60409081528501356001600160801b0381168114611881578283fd5b8152611890866060870161173b565b60208201526118a28660a0870161173b565b60408201526118b48660e087016116c4565b6060820152809150509250925092565b60008060008060008060c087890312156118dc578182fd5b8635955060208701359450604087013593506118fa6060880161179f565b92506080870135915060a087013590509295509295509295565b90815260200190565b602080825260029082015261150d60f21b604082015260600190565b602080825260029082015261054360f41b604082015260600190565b6020808252600290820152612a1960f11b604082015260600190565b602080825260029082015261543360f01b604082015260600190565b602080825260029082015261543560f01b60408201526060019056fe53616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974735369676e6564536166654d6174683a206164646974696f6e206f766572666c6f775369676e6564536166654d6174683a206469766973696f6e206f766572666c6f77536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f775369676e6564536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f7753616665436173743a2076616c756520646f65736e27742066697420696e20616e20696e743235365369676e6564536166654d6174683a207375627472616374696f6e206f766572666c6f77a264697066735822122038b27c8d03240b3121fccc5d232fd6d9190106e907541b35522546914495cfcf64736f6c63430007060033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "addUsdcPosition(TraderVaultLib.TraderVault storage,int256)": {
        "params": {
          "_traderVault": "trader vault object",
          "_usdcPositionToAdd": "amount to add. value is always positive."
        }
      },
      "decreaseLiquidationReward(TraderVaultLib.TraderVault storage,int256,int256)": {
        "params": {
          "_liquidationFee": "liquidation fee rate",
          "_minCollateral": "min collateral",
          "_traderVault": "trader vault object"
        }
      },
      "setInsolvencyFlagIfNeeded(TraderVaultLib.TraderVault storage)": {
        "params": {
          "_traderVault": "trader vault object"
        }
      },
      "updateUsdcPosition(TraderVaultLib.TraderVault storage,int256,IPerpetualMarketCore.TradePriceInfo)": {
        "params": {
          "_tradePriceInfo": "trade price info",
          "_traderVault": "trader vault object",
          "_usdcPositionToAdd": "amount to add. if positive then increase amount, if negative then decrease amount."
        },
        "returns": {
          "finalUsdcPosition": "positive means amount of deposited margin and negative means amount of withdrawn margin."
        }
      },
      "updateVault(TraderVaultLib.TraderVault storage,uint256,uint256,int128,uint256,int256)": {
        "params": {
          "_fundingFeePerPosition": "entry funding fee paid per position",
          "_positionPerpetual": "amount of position to increase or decrease",
          "_productId": "product id",
          "_subVaultIndex": "index of sub-vault",
          "_tradePrice": "trade price",
          "_traderVault": "trader vault object"
        }
      }
    },
    "stateVariables": {
      "MIN_MARGIN": {
        "details": "minimum margin is 500 USDC"
      },
      "RISK_PARAM_FOR_VAULT": {
        "details": "risk parameter for MinCollateral calculation is 5.0%"
      }
    },
    "title": "TraderVaultLib",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "addUsdcPosition(TraderVaultLib.TraderVault storage,int256)": {
        "notice": "Add USDC position"
      },
      "decreaseLiquidationReward(TraderVaultLib.TraderVault storage,int256,int256)": {
        "notice": "Decreases liquidation reward from usdc position"
      },
      "setInsolvencyFlagIfNeeded(TraderVaultLib.TraderVault storage)": {
        "notice": "Set insolvency flag if needed If PositionValue is negative, set insolvency flag."
      },
      "updateUsdcPosition(TraderVaultLib.TraderVault storage,int256,IPerpetualMarketCore.TradePriceInfo)": {
        "notice": "Updates USDC position"
      },
      "updateVault(TraderVaultLib.TraderVault storage,uint256,uint256,int128,uint256,int256)": {
        "notice": "Updates positions in the vault"
      }
    },
    "notice": "TraderVaultLib has functions to calculate position value and minimum collateral for implementing cross margin wallet. Data Structure  Vault  - PositionUSDC  - SubVault0(PositionPerpetuals, EntryPrices, entryFundingFee)  - SubVault1(PositionPerpetuals, EntryPrices, entryFundingFee)  - ...  PositionPerpetuals = [PositionSqueeth, PositionFuture]  EntryPrices = [EntryPriceSqueeth, EntryPriceFuture]  entryFundingFee = [entryFundingFeeqeeth, FundingFeeEntryValueFuture] Error codes  T0: PositionValue must be greater than MinCollateral  T1: PositionValue must be less than MinCollateral  T2: Vault is insolvent  T3: subVaultIndex is too large  T4: position must not be 0  T5: usdc to add must be positive",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}