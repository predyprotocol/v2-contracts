{
  "address": "0xfCA12D4bB34Cf088D3d57ABBce14e8b18d60cc75",
  "abi": [],
  "transactionHash": "0xbae69e094fbec4e295ebcf07d87b2f04a7622ae85d826dd3dd798d415e462547",
  "receipt": {
    "to": null,
    "from": "0x4f071924D66BBC71A5254217893CC7D49938B1c4",
    "contractAddress": "0xfCA12D4bB34Cf088D3d57ABBce14e8b18d60cc75",
    "transactionIndex": 0,
    "gasUsed": "23077645",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xdcc8b433c45c5297947073663716028e43eba032a3837705fdfa89b87ddec8ef",
    "transactionHash": "0xbae69e094fbec4e295ebcf07d87b2f04a7622ae85d826dd3dd798d415e462547",
    "logs": [],
    "blockNumber": 8769958,
    "cumulativeGasUsed": "10656265",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "f28d5428443580541197f9666bda8cf1",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"decreaseLiquidationReward(TraderVaultLib.TraderVault storage,int256,int256)\":{\"params\":{\"_liquidationFee\":\"liquidation fee rate\",\"_minCollateral\":\"min collateral\",\"_traderVault\":\"trader vault object\"}},\"setInsolvencyFlagIfNeeded(TraderVaultLib.TraderVault storage)\":{\"params\":{\"_traderVault\":\"trader vault object\"}},\"updateUsdcPosition(TraderVaultLib.TraderVault storage,int256,IPerpetualMarketCore.TradePriceInfo)\":{\"params\":{\"_tradePriceInfo\":\"trade price info\",\"_traderVault\":\"trader vault object\",\"_usdcPositionToAdd\":\"amount to add. if positive then increase amount, if negative then decrease amount.\"},\"returns\":{\"finalUsdcPosition\":\"positive means amount of deposited margin and negative means amount of withdrawn margin.\"}},\"updateVault(TraderVaultLib.TraderVault storage,uint256,uint256,int128,uint256,int256)\":{\"params\":{\"_fundingFeePerPosition\":\"entry funding fee paid per position\",\"_positionPerpetual\":\"amount of position to increase or decrease\",\"_productId\":\"product id\",\"_subVaultIndex\":\"index of sub-vault\",\"_tradePrice\":\"trade price\",\"_traderVault\":\"trader vault object\"}}},\"stateVariables\":{\"MIN_MARGIN\":{\"details\":\"minimum margin is 500 USDC\"},\"RISK_PARAM_FOR_VAULT\":{\"details\":\"risk parameter for MinCollateral calculation is 5.0%\"}},\"title\":\"TraderVaultLib\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"decreaseLiquidationReward(TraderVaultLib.TraderVault storage,int256,int256)\":{\"notice\":\"Decreases liquidation reward from usdc position\"},\"setInsolvencyFlagIfNeeded(TraderVaultLib.TraderVault storage)\":{\"notice\":\"Set insolvency flag if needed If PositionValue is negative, set insolvency flag.\"},\"updateUsdcPosition(TraderVaultLib.TraderVault storage,int256,IPerpetualMarketCore.TradePriceInfo)\":{\"notice\":\"Updates USDC position\"},\"updateVault(TraderVaultLib.TraderVault storage,uint256,uint256,int128,uint256,int256)\":{\"notice\":\"Updates positions in the vault\"}},\"notice\":\"TraderVaultLib has functions to calculate position value and minimum collateral for implementing cross margin wallet. Data Structure  Vault  - PositionUSDC  - SubVault0(PositionPerpetuals, EntryPrices, entryFundingFee)  - SubVault1(PositionPerpetuals, EntryPrices, entryFundingFee)  - ...  PositionPerpetuals = [PositionSqueeth, PositionFuture]  EntryPrices = [EntryPriceSqueeth, EntryPriceFuture]  entryFundingFee = [entryFundingFeeqeeth, FundingFeeEntryValueFuture] Error codes  T0: PositionValue must be greater than MinCollateral  T1: PositionValue must be less than MinCollateral  T2: Vault is insolvent  T3: subVaultIndex is too large  T4: position must not be 0\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/lib/TraderVaultLib.sol\":\"TraderVaultLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xe22a1fc7400ae196eba2ad1562d0386462b00a6363b742d55a2fd2021a58586f\",\"license\":\"MIT\"},\"@openzeppelin/contracts/math/SignedSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title SignedSafeMath\\n * @dev Signed math operations with safety checks that revert on error.\\n */\\nlibrary SignedSafeMath {\\n    int256 constant private _INT256_MIN = -2**255;\\n\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int256 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 && a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\",\"keccak256\":\"0xba085261d44cf28d2583f7c8cdb2f0a6a495ff1a640f86d995ea9d36b42b0046\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= -2**127 && value < 2**127, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= -2**63 && value < 2**63, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= -2**31 && value < 2**31, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= -2**15 && value < 2**15, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= -2**7 && value < 2**7, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(value < 2**255, \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x79004a1d1471abe87e92c4497acba06d5dfa5b1f3e9894a0991a7c4669c5c02c\",\"license\":\"MIT\"},\"contracts/interfaces/IPerpetualMarketCore.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../lib/NettingLib.sol\\\";\\n\\ninterface IPerpetualMarketCore {\\n    struct TradePriceInfo {\\n        uint128 spotPrice;\\n        int256[2] tradePrices;\\n        int256[2] fundingRates;\\n        int128[2] amountsFundingPaidPerPosition;\\n    }\\n\\n    function initialize(\\n        address _depositor,\\n        uint256 _depositAmount,\\n        int256 _initialFundingRate\\n    ) external returns (uint256 mintAmount);\\n\\n    function deposit(address _depositor, uint256 _depositAmount) external returns (uint256 mintAmount);\\n\\n    function withdraw(address _withdrawer, uint256 _withdrawnAmount) external returns (uint256 burnAmount);\\n\\n    function addLiquidity(uint256 _amount) external;\\n\\n    function updatePoolPosition(uint256 _productId, int128 _tradeAmount)\\n        external\\n        returns (\\n            uint256 tradePrice,\\n            int256,\\n            uint256 protocolFee\\n        );\\n\\n    function completeHedgingProcedure(NettingLib.CompleteParams memory _completeParams) external;\\n\\n    function updatePoolSnapshot() external;\\n\\n    function executeFundingPayment() external;\\n\\n    function getTradePriceInfo(int128[2] memory amountAssets) external view returns (TradePriceInfo memory);\\n\\n    function getTradePrice(uint256 _productId, int128 _tradeAmount)\\n        external\\n        view\\n        returns (\\n            int256,\\n            int256,\\n            int256,\\n            int256,\\n            int256\\n        );\\n\\n    function rebalance() external;\\n\\n    function getTokenAmountForHedging() external view returns (NettingLib.CompleteParams memory completeParams);\\n\\n    function getLPTokenPrice(int256 _deltaLiquidityAmount) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xc7cb9a7e856b7cdca89801119acab5bbf197765b81a68beccefc6d63e54d3d7c\",\"license\":\"agpl-3.0\"},\"contracts/lib/EntryPriceMath.sol\":{\"content\":\"//SPDX-License-Identifier: agpl-3.0\\npragma solidity =0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/utils/SafeCast.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SignedSafeMath.sol\\\";\\nimport \\\"./Math.sol\\\";\\n\\n/**\\n * @title EntryPriceMath\\n * @notice Library contract which has functions to calculate new entry price and profit\\n * from previous entry price and trade price for implementing margin wallet.\\n */\\nlibrary EntryPriceMath {\\n    using SafeCast for uint256;\\n    using SafeMath for uint256;\\n    using SignedSafeMath for int256;\\n\\n    /**\\n     * @notice Calculates new entry price and return profit if position is closed\\n     *\\n     * Calculation Patterns\\n     *  |Position|PositionTrade|NewPosition|Pattern|\\n     *  |       +|            +|          +|      A|\\n     *  |       +|            -|          +|      B|\\n     *  |       +|            -|          -|      C|\\n     *  |       -|            -|          -|      A|\\n     *  |       -|            +|          -|      B|\\n     *  |       -|            +|          +|      C|\\n     *\\n     * Calculations\\n     *  Pattern A (open positions)\\n     *   NewEntryPrice = (EntryPrice * |Position| + TradePrce * |PositionTrade|) / (Position + PositionTrade)\\n     *\\n     *  Pattern B (close positions)\\n     *   NewEntryPrice = EntryPrice\\n     *   ProfitValue = -PositionTrade * (TradePrice - EntryPrice)\\n     *\\n     *  Pattern C (close all positions & open new)\\n     *   NewEntryPrice = TradePrice\\n     *   ProfitValue = Position * (TradePrice - EntryPrice)\\n     *\\n     * @param _entryPrice previous entry price\\n     * @param _position current position\\n     * @param _tradePrice trade price\\n     * @param _positionTrade position to trade\\n     * @return newEntryPrice new entry price\\n     * @return profitValue notional profit value when positions are closed\\n     */\\n    function updateEntryPrice(\\n        int256 _entryPrice,\\n        int256 _position,\\n        int256 _tradePrice,\\n        int256 _positionTrade\\n    ) internal pure returns (int256 newEntryPrice, int256 profitValue) {\\n        int256 newPosition = _position.add(_positionTrade);\\n        if (_position == 0 || (_position > 0 && _positionTrade > 0) || (_position < 0 && _positionTrade < 0)) {\\n            newEntryPrice = (\\n                _entryPrice.mul(int256(Math.abs(_position))).add(_tradePrice.mul(int256(Math.abs(_positionTrade))))\\n            ).div(int256(Math.abs(_position.add(_positionTrade))));\\n        } else if (\\n            (_position > 0 && _positionTrade < 0 && newPosition > 0) ||\\n            (_position < 0 && _positionTrade > 0 && newPosition < 0)\\n        ) {\\n            newEntryPrice = _entryPrice;\\n            profitValue = (-_positionTrade).mul(_tradePrice.sub(_entryPrice)) / 1e8;\\n        } else {\\n            if (newPosition != 0) {\\n                newEntryPrice = _tradePrice;\\n            }\\n\\n            profitValue = _position.mul(_tradePrice.sub(_entryPrice)) / 1e8;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x76b69923c0d21ff5a04335743b0b4f64ff36a90df6154f030914231abf47c858\",\"license\":\"agpl-3.0\"},\"contracts/lib/Math.sol\":{\"content\":\"//SPDX-License-Identifier: agpl-3.0\\npragma solidity =0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/SignedSafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n * Error codes\\n * M0: y is too small\\n * M1: y is too large\\n * M2: possible overflow\\n * M3: input should be positive number\\n * M4: cannot handle exponents greater than 100\\n */\\nlibrary Math {\\n    using SafeMath for uint256;\\n    using SignedSafeMath for int256;\\n\\n    /// @dev Min exp\\n    int256 private constant MIN_EXP = -63 * 1e8;\\n    /// @dev Max exp\\n    uint256 private constant MAX_EXP = 100 * 1e8;\\n    /// @dev ln(2) scaled by 1e8\\n    uint256 private constant LN_2_E8 = 69314718;\\n\\n    /**\\n     * @notice Return the addition of unsigned integer and sigined integer.\\n     * when y is negative reverting on negative result and when y is positive reverting on overflow.\\n     */\\n    function addDelta(uint256 x, int256 y) internal pure returns (uint256 z) {\\n        if (y < 0) {\\n            require((z = x - uint256(-y)) < x, \\\"M0\\\");\\n        } else {\\n            require((z = x + uint256(y)) >= x, \\\"M1\\\");\\n        }\\n    }\\n\\n    function abs(int256 x) internal pure returns (uint256) {\\n        return uint256(x >= 0 ? x : -x);\\n    }\\n\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? b : a;\\n    }\\n\\n    /**\\n     * @notice Returns scaled number.\\n     * Reverts if the scaler is greater than 50.\\n     */\\n    function scale(\\n        uint256 _a,\\n        uint256 _from,\\n        uint256 _to\\n    ) internal pure returns (uint256) {\\n        if (_from > _to) {\\n            require(_from - _to < 70, \\\"M2\\\");\\n            // (_from - _to) is safe because _from > _to.\\n            // 10**(_from - _to) is safe because it's less than 10**70.\\n            return _a.div(10**(_from - _to));\\n        } else if (_from < _to) {\\n            require(_to - _from < 70, \\\"M2\\\");\\n            // (_to - _from) is safe because _to > _from.\\n            // 10**(_to - _from) is safe because it's less than 10**70.\\n            return _a.mul(10**(_to - _from));\\n        } else {\\n            return _a;\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates an approximate value of the logarithm of input value by Halley's method.\\n     */\\n    function log(uint256 x) internal pure returns (int256) {\\n        int256 res;\\n        int256 next;\\n\\n        for (uint256 i = 0; i < 8; i++) {\\n            int256 e = int256(exp(res));\\n            next = res.add((int256(x).sub(e).mul(2)).mul(1e8).div(int256(x).add(e)));\\n            if (next == res) {\\n                break;\\n            }\\n            res = next;\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * @dev Returns the exponent of the value using Taylor expansion with support for negative numbers.\\n     */\\n    function exp(int256 x) internal pure returns (uint256) {\\n        if (0 <= x) {\\n            return exp(uint256(x));\\n        } else if (x < MIN_EXP) {\\n            // return 0 because `exp(-63) < 1e-27`\\n            return 0;\\n        } else {\\n            return uint256(1e8).mul(1e8).div(exp(uint256(-x)));\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates the exponent of the value using Taylor expansion.\\n     */\\n    function exp(uint256 x) internal pure returns (uint256) {\\n        if (x == 0) {\\n            return 1e8;\\n        }\\n        require(x <= MAX_EXP, \\\"M4\\\");\\n\\n        uint256 k = floor(x.mul(1e8).div(LN_2_E8)) / 1e8;\\n        uint256 p = 2**k;\\n        uint256 r = x.sub(k.mul(LN_2_E8));\\n\\n        uint256 multiplier = 1e8;\\n\\n        uint256 lastMultiplier;\\n        for (uint256 i = 16; i > 0; i--) {\\n            multiplier = multiplier.mul(r / i).div(1e8).add(1e8);\\n            if (multiplier == lastMultiplier) {\\n                break;\\n            }\\n            lastMultiplier = multiplier;\\n        }\\n\\n        return p.mul(multiplier);\\n    }\\n\\n    /**\\n     * @dev Returns the floor of a 1e8\\n     */\\n    function floor(uint256 x) internal pure returns (uint256) {\\n        return x - (x % 1e8);\\n    }\\n}\\n\",\"keccak256\":\"0x4c727725db8061888428559bc5d0326471b629b0eeb5f42ddd41b3082d6d0b01\",\"license\":\"agpl-3.0\"},\"contracts/lib/NettingLib.sol\":{\"content\":\"//SPDX-License-Identifier: agpl-3.0\\npragma solidity =0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/utils/SafeCast.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SignedSafeMath.sol\\\";\\nimport \\\"./Math.sol\\\";\\n\\n/**\\n * @title NettingLib\\n * Error codes\\n * N0: Unknown product id\\n * N1: Total delta must be greater than 0\\n * N2: No enough USDC\\n */\\nlibrary NettingLib {\\n    using SafeCast for int256;\\n    using SafeCast for uint128;\\n    using SafeCast for uint256;\\n    using SafeMath for uint256;\\n    using SafeMath for uint128;\\n    using SignedSafeMath for int256;\\n    using SignedSafeMath for int128;\\n\\n    struct AddMarginParams {\\n        int256 delta0;\\n        int256 delta1;\\n        int256 gamma1;\\n        int256 spotPrice;\\n        int256 poolMarginRiskParam;\\n    }\\n\\n    struct CompleteParams {\\n        uint256 amountUsdc;\\n        uint256 amountUnderlying;\\n        int256[2] amountsRequiredUnderlying;\\n        bool isLong;\\n    }\\n\\n    struct Info {\\n        uint128 amountAaveCollateral;\\n        uint128[2] amountsUsdc;\\n        int128[2] amountsUnderlying;\\n    }\\n\\n    /**\\n     * @notice Adds required margin for delta hedging\\n     */\\n    function addMargin(\\n        Info storage _info,\\n        uint256 _productId,\\n        AddMarginParams memory _params\\n    ) internal returns (int256 requiredMargin, int256 hedgePositionValue) {\\n        int256 totalRequiredMargin = getRequiredMargin(_productId, _params);\\n\\n        hedgePositionValue = getHedgePositionValue(_info, _params.spotPrice, _productId);\\n\\n        requiredMargin = totalRequiredMargin.sub(hedgePositionValue);\\n\\n        if (_info.amountsUsdc[_productId].toInt256().add(requiredMargin) < 0) {\\n            requiredMargin = -_info.amountsUsdc[_productId].toInt256();\\n        }\\n\\n        _info.amountsUsdc[_productId] = Math.addDelta(_info.amountsUsdc[_productId], requiredMargin).toUint128();\\n    }\\n\\n    function getRequiredTokenAmountsForHedge(\\n        int128[2] memory _amountsUnderlying,\\n        int256[2] memory _deltas,\\n        int256 _spotPrice\\n    ) internal pure returns (CompleteParams memory completeParams) {\\n        completeParams.amountsRequiredUnderlying[0] = -_amountsUnderlying[0] - _deltas[0];\\n        completeParams.amountsRequiredUnderlying[1] = -_amountsUnderlying[1] - _deltas[1];\\n\\n        int256 totalUnderlyingPosition = getTotalUnderlyingPosition(_amountsUnderlying);\\n\\n        // 1. Calculate required amount of underlying token\\n        int256 requiredUnderlyingAmount;\\n        {\\n            // required amount is -(net delta)\\n            requiredUnderlyingAmount = -_deltas[0].add(_deltas[1]).add(totalUnderlyingPosition);\\n\\n            if (_deltas[0].add(_deltas[1]) > 0) {\\n                // if pool delta is positive\\n                requiredUnderlyingAmount = -totalUnderlyingPosition;\\n\\n                completeParams.amountsRequiredUnderlying[0] = -_amountsUnderlying[0] + _deltas[1];\\n            }\\n\\n            completeParams.isLong = requiredUnderlyingAmount > 0;\\n        }\\n\\n        // 2. Calculate USDC and ETH amounts.\\n        completeParams.amountUnderlying = Math.abs(requiredUnderlyingAmount);\\n        completeParams.amountUsdc = (Math.abs(requiredUnderlyingAmount).mul(uint256(_spotPrice))) / 1e8;\\n\\n        return completeParams;\\n    }\\n\\n    /**\\n     * @notice Completes delta hedging procedure\\n     * Calculate holding amount of Underlying and USDC after a hedge.\\n     */\\n    function complete(Info storage _info, CompleteParams memory _params) internal {\\n        uint256 totalUnderlying = Math.abs(_params.amountsRequiredUnderlying[0]).add(\\n            Math.abs(_params.amountsRequiredUnderlying[1])\\n        );\\n\\n        require(totalUnderlying > 0, \\\"N1\\\");\\n\\n        for (uint256 i = 0; i < 2; i++) {\\n            _info.amountsUnderlying[i] = _info\\n                .amountsUnderlying[i]\\n                .add(_params.amountsRequiredUnderlying[i])\\n                .toInt128();\\n\\n            {\\n                uint256 deltaUsdcAmount = (_params.amountUsdc.mul(Math.abs(_params.amountsRequiredUnderlying[i]))).div(\\n                    totalUnderlying\\n                );\\n\\n                if (_params.isLong) {\\n                    require(_info.amountsUsdc[i] >= deltaUsdcAmount, \\\"N2\\\");\\n                    _info.amountsUsdc[i] = _info.amountsUsdc[i].sub(deltaUsdcAmount).toUint128();\\n                } else {\\n                    _info.amountsUsdc[i] = _info.amountsUsdc[i].add(deltaUsdcAmount).toUint128();\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets required margin\\n     * @param _productId Id of product to get required margin\\n     * @param _params parameters to calculate required margin\\n     * @return RequiredMargin scaled by 1e8\\n     */\\n    function getRequiredMargin(uint256 _productId, AddMarginParams memory _params) internal pure returns (int256) {\\n        int256 weightedDelta = calculateWeightedDelta(_productId, _params.delta0, _params.delta1);\\n\\n        if (_productId == 0) {\\n            return getRequiredMarginOfFuture(_params, weightedDelta);\\n        } else if (_productId == 1) {\\n            return getRequiredMarginOfSqueeth(_params, weightedDelta);\\n        } else {\\n            revert(\\\"N0\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets required margin for future\\n     * RequiredMargin_{future} = (1+\\u03b1)*S*|WeightedDelta|\\n     * @return RequiredMargin scaled by 1e8\\n     */\\n    function getRequiredMarginOfFuture(AddMarginParams memory _params, int256 _weightedDelta)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        int256 requiredMargin = (_params.spotPrice.mul(Math.abs(_weightedDelta).toInt256())) / 1e8;\\n        return ((1e4 + _params.poolMarginRiskParam).mul(requiredMargin)) / 1e4;\\n    }\\n\\n    /**\\n     * @notice Gets required margin for squeeth\\n     * RequiredMargin_{squeeth}\\n     * = max((1-\\u03b1) * S * |WeightDelta_{sqeeth}-\\u03b1 * S * gamma|, (1+\\u03b1) * S * |WeightDelta_{sqeeth}+\\u03b1 * S * gamma|)\\n     * @return RequiredMargin scaled by 1e8\\n     */\\n    function getRequiredMarginOfSqueeth(AddMarginParams memory _params, int256 _weightedDelta)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        int256 deltaFromGamma = (_params.poolMarginRiskParam.mul(_params.spotPrice).mul(_params.gamma1)) / 1e12;\\n\\n        return\\n            Math.max(\\n                (\\n                    (1e4 - _params.poolMarginRiskParam).mul(_params.spotPrice).mul(\\n                        Math.abs(_weightedDelta.sub(deltaFromGamma)).toInt256()\\n                    )\\n                ) / 1e12,\\n                (\\n                    (1e4 + _params.poolMarginRiskParam).mul(_params.spotPrice).mul(\\n                        Math.abs(_weightedDelta.add(deltaFromGamma)).toInt256()\\n                    )\\n                ) / 1e12\\n            );\\n    }\\n\\n    /**\\n     * @notice Gets notional value of hedge positions\\n     * HedgePositionValue_i = AmountsUsdc_i+AmountsUnderlying_i*S\\n     * @return HedgePositionValue scaled by 1e8\\n     */\\n    function getHedgePositionValue(\\n        Info memory _info,\\n        int256 _spot,\\n        uint256 _productId\\n    ) internal pure returns (int256) {\\n        int256 hedgeNotional = _spot.mul(_info.amountsUnderlying[_productId]) / 1e8;\\n\\n        return _info.amountsUsdc[_productId].toInt256().add(hedgeNotional);\\n    }\\n\\n    /**\\n     * @notice Gets total underlying position\\n     * TotalUnderlyingPosition = \\u03a3AmountsUnderlying_i\\n     */\\n    function getTotalUnderlyingPosition(int128[2] memory _amountsUnderlying)\\n        internal\\n        pure\\n        returns (int256 underlyingPosition)\\n    {\\n        for (uint256 i = 0; i < 2; i++) {\\n            underlyingPosition = underlyingPosition.add(_amountsUnderlying[i]);\\n        }\\n\\n        return underlyingPosition;\\n    }\\n\\n    /**\\n     * @notice Calculates weighted delta\\n     * WeightedDelta = delta_i * (\\u03a3delta_i) / (\\u03a3|delta_i|)\\n     * @return weighted delta scaled by 1e8\\n     */\\n    function calculateWeightedDelta(\\n        uint256 _productId,\\n        int256 _delta0,\\n        int256 _delta1\\n    ) internal pure returns (int256) {\\n        int256 netDelta = _delta0.add(_delta1);\\n        int256 totalDelta = (Math.abs(_delta0).add(Math.abs(_delta1))).toInt256();\\n\\n        require(totalDelta >= 0, \\\"N1\\\");\\n\\n        if (totalDelta == 0) {\\n            return 0;\\n        }\\n\\n        if (_productId == 0) {\\n            return (Math.abs(_delta0).toInt256().mul(netDelta)).div(totalDelta);\\n        } else if (_productId == 1) {\\n            return (Math.abs(_delta1).toInt256().mul(netDelta)).div(totalDelta);\\n        } else {\\n            revert(\\\"N0\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x46f6b430287b0cab11606278f5d69a3bd72d536e857a8e9601fa41a1f5ab48e9\",\"license\":\"agpl-3.0\"},\"contracts/lib/TraderVaultLib.sol\":{\"content\":\"//SPDX-License-Identifier: agpl-3.0\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/utils/SafeCast.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SignedSafeMath.sol\\\";\\nimport \\\"../interfaces/IPerpetualMarketCore.sol\\\";\\nimport \\\"./Math.sol\\\";\\nimport \\\"./EntryPriceMath.sol\\\";\\n\\n/**\\n * @title TraderVaultLib\\n * @notice TraderVaultLib has functions to calculate position value and minimum collateral for implementing cross margin wallet.\\n *\\n * Data Structure\\n *  Vault\\n *  - PositionUSDC\\n *  - SubVault0(PositionPerpetuals, EntryPrices, entryFundingFee)\\n *  - SubVault1(PositionPerpetuals, EntryPrices, entryFundingFee)\\n *  - ...\\n *\\n *  PositionPerpetuals = [PositionSqueeth, PositionFuture]\\n *  EntryPrices = [EntryPriceSqueeth, EntryPriceFuture]\\n *  entryFundingFee = [entryFundingFeeqeeth, FundingFeeEntryValueFuture]\\n *\\n *\\n * Error codes\\n *  T0: PositionValue must be greater than MinCollateral\\n *  T1: PositionValue must be less than MinCollateral\\n *  T2: Vault is insolvent\\n *  T3: subVaultIndex is too large\\n *  T4: position must not be 0\\n */\\nlibrary TraderVaultLib {\\n    using SafeCast for int256;\\n    using SafeCast for uint256;\\n    using SafeCast for uint128;\\n    using SafeMath for uint256;\\n    using SignedSafeMath for int256;\\n    using SignedSafeMath for int128;\\n\\n    uint256 private constant MAX_PRODUCT_ID = 2;\\n\\n    /// @dev minimum margin is 500 USDC\\n    uint256 private constant MIN_MARGIN = 500 * 1e8;\\n\\n    /// @dev risk parameter for MinCollateral calculation is 5.0%\\n    uint256 private constant RISK_PARAM_FOR_VAULT = 500;\\n\\n    struct SubVault {\\n        int128[2] positionPerpetuals;\\n        uint128[2] entryPrices;\\n        int128[2] entryFundingFee;\\n    }\\n\\n    struct TraderVault {\\n        int128 positionUsdc;\\n        SubVault[] subVaults;\\n        bool isInsolvent;\\n    }\\n\\n    /**\\n     * @notice Gets amount of min collateral to add Squees/Future\\n     * @param _traderVault trader vault object\\n     * @param _tradeAmounts amount to trade\\n     * @param _tradePriceInfo trade price info\\n     * @return minCollateral and positionValue\\n     */\\n    function getMinCollateralToAddPosition(\\n        TraderVault memory _traderVault,\\n        int128[2] memory _tradeAmounts,\\n        IPerpetualMarketCore.TradePriceInfo memory _tradePriceInfo\\n    ) internal pure returns (int256 minCollateral) {\\n        int128[2] memory positionPerpetuals = getPositionPerpetuals(_traderVault);\\n\\n        for (uint256 i = 0; i < MAX_PRODUCT_ID; i++) {\\n            positionPerpetuals[i] = positionPerpetuals[i].add(_tradeAmounts[i]).toInt128();\\n        }\\n\\n        minCollateral = calculateMinCollateral(positionPerpetuals, _tradePriceInfo);\\n    }\\n\\n    /**\\n     * @notice Updates USDC position\\n     * @param _traderVault trader vault object\\n     * @param _usdcPositionToAdd amount to add. if positive then increase amount, if negative then decrease amount.\\n     * @param _tradePriceInfo trade price info\\n     * @return finalUsdcPosition positive means amount of deposited margin\\n     * and negative means amount of withdrawn margin.\\n     */\\n    function updateUsdcPosition(\\n        TraderVault storage _traderVault,\\n        int256 _usdcPositionToAdd,\\n        IPerpetualMarketCore.TradePriceInfo memory _tradePriceInfo\\n    ) external returns (int256 finalUsdcPosition) {\\n        finalUsdcPosition = _usdcPositionToAdd;\\n        require(!_traderVault.isInsolvent, \\\"T2\\\");\\n\\n        int256 positionValue = getPositionValue(_traderVault, _tradePriceInfo);\\n        int256 minCollateral = getMinCollateral(_traderVault, _tradePriceInfo);\\n        int256 maxWithdrawable = positionValue - minCollateral;\\n\\n        // If trader wants to withdraw all USDC, set maxWithdrawable.\\n        if (_usdcPositionToAdd < -maxWithdrawable && maxWithdrawable > 0 && _usdcPositionToAdd < 0) {\\n            finalUsdcPosition = -maxWithdrawable;\\n        }\\n\\n        _traderVault.positionUsdc = _traderVault.positionUsdc.add(finalUsdcPosition).toInt128();\\n\\n        require(!checkVaultIsLiquidatable(_traderVault, _tradePriceInfo), \\\"T0\\\");\\n    }\\n\\n    /**\\n     * @notice Gets total position of perpetuals in the vault\\n     * @param _traderVault trader vault object\\n     * @return positionPerpetuals are total amount of perpetual scaled by 1e8\\n     */\\n    function getPositionPerpetuals(TraderVault memory _traderVault)\\n        internal\\n        pure\\n        returns (int128[2] memory positionPerpetuals)\\n    {\\n        for (uint256 i = 0; i < MAX_PRODUCT_ID; i++) {\\n            positionPerpetuals[i] = getPositionPerpetual(_traderVault, i);\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets position of a perpetual in the vault\\n     * @param _traderVault trader vault object\\n     * @param _productId product id\\n     * @return positionPerpetual is amount of perpetual scaled by 1e8\\n     */\\n    function getPositionPerpetual(TraderVault memory _traderVault, uint256 _productId)\\n        internal\\n        pure\\n        returns (int128 positionPerpetual)\\n    {\\n        for (uint256 i = 0; i < _traderVault.subVaults.length; i++) {\\n            positionPerpetual = positionPerpetual\\n                .add(_traderVault.subVaults[i].positionPerpetuals[_productId])\\n                .toInt128();\\n        }\\n    }\\n\\n    /**\\n     * @notice Updates positions in the vault\\n     * @param _traderVault trader vault object\\n     * @param _subVaultIndex index of sub-vault\\n     * @param _productId product id\\n     * @param _positionPerpetual amount of position to increase or decrease\\n     * @param _tradePrice trade price\\n     * @param _fundingFeePerPosition entry funding fee paid per position\\n     */\\n    function updateVault(\\n        TraderVault storage _traderVault,\\n        uint256 _subVaultIndex,\\n        uint256 _productId,\\n        int128 _positionPerpetual,\\n        uint256 _tradePrice,\\n        int256 _fundingFeePerPosition\\n    ) external returns (int256 deltaUsdcPosition) {\\n        require(!_traderVault.isInsolvent, \\\"T2\\\");\\n        require(_positionPerpetual != 0, \\\"T4\\\");\\n\\n        if (_traderVault.subVaults.length == _subVaultIndex) {\\n            int128[2] memory positionPerpetuals;\\n            uint128[2] memory entryPrices;\\n            int128[2] memory entryFundingFee;\\n\\n            _traderVault.subVaults.push(SubVault(positionPerpetuals, entryPrices, entryFundingFee));\\n        } else {\\n            require(_traderVault.subVaults.length > _subVaultIndex, \\\"T3\\\");\\n        }\\n\\n        SubVault storage subVault = _traderVault.subVaults[_subVaultIndex];\\n\\n        {\\n            (int256 newEntryPrice, int256 profitValue) = EntryPriceMath.updateEntryPrice(\\n                int256(subVault.entryPrices[_productId]),\\n                subVault.positionPerpetuals[_productId],\\n                int256(_tradePrice),\\n                _positionPerpetual\\n            );\\n\\n            subVault.entryPrices[_productId] = newEntryPrice.toUint256().toUint128();\\n            deltaUsdcPosition = deltaUsdcPosition.add(profitValue);\\n        }\\n\\n        {\\n            (int256 newEntryFundingFee, int256 profitValue) = EntryPriceMath.updateEntryPrice(\\n                int256(subVault.entryFundingFee[_productId]),\\n                subVault.positionPerpetuals[_productId],\\n                _fundingFeePerPosition,\\n                _positionPerpetual\\n            );\\n\\n            subVault.entryFundingFee[_productId] = newEntryFundingFee.toInt128();\\n            deltaUsdcPosition = deltaUsdcPosition.sub(profitValue);\\n        }\\n\\n        _traderVault.positionUsdc = _traderVault.positionUsdc.add(deltaUsdcPosition).toInt128();\\n\\n        subVault.positionPerpetuals[_productId] = subVault\\n            .positionPerpetuals[_productId]\\n            .add(_positionPerpetual)\\n            .toInt128();\\n    }\\n\\n    /**\\n     * @notice Checks the vault is liquidatable and return result\\n     * if PositionValue is less than MinCollateral return true\\n     * otherwise return false\\n     * @param _traderVault trader vault object\\n     * @return if true the vault is liquidatable, if false the vault is not liquidatable\\n     */\\n    function checkVaultIsLiquidatable(\\n        TraderVault memory _traderVault,\\n        IPerpetualMarketCore.TradePriceInfo memory _tradePriceInfo\\n    ) internal pure returns (bool) {\\n        int256 positionValue = getPositionValue(_traderVault, _tradePriceInfo);\\n\\n        return positionValue < getMinCollateral(_traderVault, _tradePriceInfo);\\n    }\\n\\n    /**\\n     * @notice Set insolvency flag if needed\\n     * If PositionValue is negative, set insolvency flag.\\n     * @param _traderVault trader vault object\\n     */\\n    function setInsolvencyFlagIfNeeded(TraderVault storage _traderVault) external {\\n        // Confirm that there are no positions\\n        for (uint256 i = 0; i < _traderVault.subVaults.length; i++) {\\n            for (uint256 j = 0; j < MAX_PRODUCT_ID; j++) {\\n                require(_traderVault.subVaults[i].positionPerpetuals[j] == 0);\\n            }\\n        }\\n\\n        // If there are no positions, PositionUSDC is equal to PositionValue.\\n        if (_traderVault.positionUsdc < 0) {\\n            _traderVault.isInsolvent = true;\\n        }\\n    }\\n\\n    /**\\n     * @notice Decreases liquidation reward from usdc position\\n     * @param _traderVault trader vault object\\n     * @param _minCollateral min collateral\\n     * @param _liquidationFee liquidation fee rate\\n     */\\n    function decreaseLiquidationReward(\\n        TraderVault storage _traderVault,\\n        int256 _minCollateral,\\n        int256 _liquidationFee\\n    ) external returns (uint256) {\\n        if (_traderVault.positionUsdc <= 0) {\\n            return 0;\\n        }\\n\\n        int256 reward = _minCollateral.mul(_liquidationFee).div(1e4);\\n\\n        reward = Math.min(reward, _traderVault.positionUsdc);\\n\\n        // reduce margin\\n        // sub is safe because we know reward is less than positionUsdc\\n        _traderVault.positionUsdc -= reward.toInt128();\\n\\n        return reward.toUint256();\\n    }\\n\\n    /**\\n     * @notice Gets min collateral of the vault\\n     * @param _traderVault trader vault object\\n     * @param _tradePriceInfo trade price info\\n     * @return MinCollateral scaled by 1e8\\n     */\\n    function getMinCollateral(\\n        TraderVault memory _traderVault,\\n        IPerpetualMarketCore.TradePriceInfo memory _tradePriceInfo\\n    ) internal pure returns (int256) {\\n        int128[2] memory assetAmounts = getPositionPerpetuals(_traderVault);\\n\\n        return calculateMinCollateral(assetAmounts, _tradePriceInfo);\\n    }\\n\\n    /**\\n     * @notice Calculates min collateral\\n     * MinCollateral = alpha*S*(|2*S*(1+fundingSqueeth)*PositionSqueeth + (1+fundingFuture)*PositionFuture| + 2*alpha*S*(1+fundingSqueeth)*|PositionSqueeth|)\\n     * where alpha is 0.05\\n     * @param positionPerpetuals amount of perpetual positions\\n     * @param _tradePriceInfo trade price info\\n     * @return MinCollateral scaled by 1e8\\n     */\\n    function calculateMinCollateral(\\n        int128[2] memory positionPerpetuals,\\n        IPerpetualMarketCore.TradePriceInfo memory _tradePriceInfo\\n    ) internal pure returns (int256) {\\n        uint256 maxDelta = Math.abs(\\n            (\\n                int256(_tradePriceInfo.spotPrice)\\n                    .mul(_tradePriceInfo.fundingRates[1].add(1e8))\\n                    .mul(positionPerpetuals[1])\\n                    .mul(2)\\n                    .div(1e20)\\n            ).add(positionPerpetuals[0].mul(_tradePriceInfo.fundingRates[0].add(1e8)).div(1e8))\\n        );\\n\\n        maxDelta = maxDelta.add(\\n            Math.abs(\\n                int256(RISK_PARAM_FOR_VAULT)\\n                    .mul(int256(_tradePriceInfo.spotPrice))\\n                    .mul(_tradePriceInfo.fundingRates[1].add(1e8))\\n                    .mul(2)\\n                    .mul(positionPerpetuals[1])\\n                    .div(1e24)\\n            )\\n        );\\n\\n        uint256 minCollateral = (RISK_PARAM_FOR_VAULT.mul(_tradePriceInfo.spotPrice).mul(maxDelta)) / 1e12;\\n\\n        if ((positionPerpetuals[0] != 0 || positionPerpetuals[1] != 0) && minCollateral < MIN_MARGIN) {\\n            minCollateral = MIN_MARGIN;\\n        }\\n\\n        return minCollateral.toInt256();\\n    }\\n\\n    /**\\n     * @notice Gets position value in the vault\\n     * PositionValue = USDC + \\u03a3(ValueOfSubVault_i)\\n     * @param _traderVault trader vault object\\n     * @param _tradePriceInfo trade price info\\n     * @return PositionValue scaled by 1e8\\n     */\\n    function getPositionValue(\\n        TraderVault memory _traderVault,\\n        IPerpetualMarketCore.TradePriceInfo memory _tradePriceInfo\\n    ) internal pure returns (int256) {\\n        int256 value = _traderVault.positionUsdc;\\n\\n        for (uint256 i = 0; i < _traderVault.subVaults.length; i++) {\\n            value = value.add(getSubVaultPositionValue(_traderVault.subVaults[i], _tradePriceInfo));\\n        }\\n\\n        return value;\\n    }\\n\\n    /**\\n     * @notice Gets position value in the sub-vault\\n     * ValueOfSubVault = TotalPerpetualValueOfSubVault + TotalFundingFeePaidOfSubVault\\n     * @param _subVault sub-vault object\\n     * @param _tradePriceInfo trade price info\\n     * @return ValueOfSubVault scaled by 1e8\\n     */\\n    function getSubVaultPositionValue(\\n        SubVault memory _subVault,\\n        IPerpetualMarketCore.TradePriceInfo memory _tradePriceInfo\\n    ) internal pure returns (int256) {\\n        return\\n            getTotalPerpetualValueOfSubVault(_subVault, _tradePriceInfo).add(\\n                getTotalFundingFeePaidOfSubVault(_subVault, _tradePriceInfo.amountsFundingPaidPerPosition)\\n            );\\n    }\\n\\n    /**\\n     * @notice Gets total perpetual value in the sub-vault\\n     * TotalPerpetualValueOfSubVault = \\u03a3(PerpetualValueOfSubVault_i)\\n     * @param _subVault sub-vault object\\n     * @param _tradePriceInfo trade price info\\n     * @return TotalPerpetualValueOfSubVault scaled by 1e8\\n     */\\n    function getTotalPerpetualValueOfSubVault(\\n        SubVault memory _subVault,\\n        IPerpetualMarketCore.TradePriceInfo memory _tradePriceInfo\\n    ) internal pure returns (int256) {\\n        int256 pnl;\\n\\n        for (uint256 i = 0; i < MAX_PRODUCT_ID; i++) {\\n            pnl = pnl.add(getPerpetualValueOfSubVault(_subVault, i, _tradePriceInfo));\\n        }\\n\\n        return pnl;\\n    }\\n\\n    /**\\n     * @notice Gets perpetual value in the sub-vault\\n     * PerpetualValueOfSubVault_i = (TradePrice_i - EntryPrice_i)*Position_i\\n     * @param _subVault sub-vault object\\n     * @param _productId product id\\n     * @param _tradePriceInfo trade price info\\n     * @return PerpetualValueOfSubVault_i scaled by 1e8\\n     */\\n    function getPerpetualValueOfSubVault(\\n        SubVault memory _subVault,\\n        uint256 _productId,\\n        IPerpetualMarketCore.TradePriceInfo memory _tradePriceInfo\\n    ) internal pure returns (int256) {\\n        int256 pnl = _tradePriceInfo.tradePrices[_productId].sub(_subVault.entryPrices[_productId].toInt256()).mul(\\n            _subVault.positionPerpetuals[_productId]\\n        );\\n\\n        return pnl / 1e8;\\n    }\\n\\n    /**\\n     * @notice Gets total funding fee in the sub-vault\\n     * TotalFundingFeePaidOfSubVault = \\u03a3(FundingFeePaidOfSubVault_i)\\n     * @param _subVault sub-vault object\\n     * @param _amountsFundingPaidPerPosition the cumulative funding fee paid by long per position\\n     * @return TotalFundingFeePaidOfSubVault scaled by 1e8\\n     */\\n    function getTotalFundingFeePaidOfSubVault(\\n        SubVault memory _subVault,\\n        int128[2] memory _amountsFundingPaidPerPosition\\n    ) internal pure returns (int256) {\\n        int256 fundingFee;\\n\\n        for (uint256 i = 0; i < MAX_PRODUCT_ID; i++) {\\n            fundingFee = fundingFee.add(getFundingFeePaidOfSubVault(_subVault, i, _amountsFundingPaidPerPosition));\\n        }\\n\\n        return fundingFee;\\n    }\\n\\n    /**\\n     * @notice Gets funding fee in the sub-vault\\n     * FundingFeePaidOfSubVault_i = Position_i*(EntryFundingFee_i - FundingFeeGlobal_i)\\n     * @param _subVault sub-vault object\\n     * @param _productId product id\\n     * @param _amountsFundingPaidPerPosition cumulative funding fee paid by long per position.\\n     * @return FundingFeePaidOfSubVault_i scaled by 1e8\\n     */\\n    function getFundingFeePaidOfSubVault(\\n        SubVault memory _subVault,\\n        uint256 _productId,\\n        int128[2] memory _amountsFundingPaidPerPosition\\n    ) internal pure returns (int256) {\\n        int256 fundingFee = _subVault.entryFundingFee[_productId].sub(_amountsFundingPaidPerPosition[_productId]).mul(\\n            _subVault.positionPerpetuals[_productId]\\n        );\\n\\n        return fundingFee / 1e8;\\n    }\\n}\\n\",\"keccak256\":\"0xae558f8183b5271867fde69d58d3d365c4d2edd14f897da14e2a3067efdb4c04\",\"license\":\"agpl-3.0\"}},\"version\":1}",
  "bytecode": "0x611a01610026600b82828239805160001a60731461001957fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100565760003560e01c80631bc045821461005b578063652aa4831461007d578063a8ffb3b9146100b3578063e69e266d146100d3575b600080fd5b81801561006757600080fd5b5061007b610076366004611713565b6100f3565b005b81801561008957600080fd5b5061009d61009836600461172b565b610198565b6040516100aa9190611855565b60405180910390f35b8180156100bf57600080fd5b5061009d6100ce366004611805565b610226565b8180156100df57600080fd5b5061009d6100ee366004611756565b6105cb565b60005b60018201548110156101725760005b60028110156101695782600101828154811061011d57fe5b9060005260206000209060030201600001816002811061013957fe5b600291828204019190066010029054906101000a9004600f0b600f0b60001461016157600080fd5b600101610105565b506001016100f6565b5080546000600f91820b90910b12156101955760028101805460ff191660011790555b50565b8254600090600f90810b900b81126101b25750600061021f565b60006101ca6127106101c48686610b74565b90610c26565b85549091506101e1908290600f90810b900b610cde565b90506101ec81610cf3565b8554600f81810b9290920390910b6001600160801b03166001600160801b031990911617855561021b81610d5c565b9150505b9392505050565b600286015460009060ff16156102575760405162461bcd60e51b815260040161024e90611896565b60405180910390fd5b83600f0b6000141561027b5760405162461bcd60e51b815260040161024e9061185e565b600187015486141561031c5761028f6114eb565b6102976114eb565b61029f6114eb565b6040805160608101825284815260208082018590529181018390526001808d01805491820181556000908152929092208151919260030201906102e59082906002611509565b5060208201516102fb90600183019060026115b1565b5060408201516103119060028084019190611509565b50505050505061033f565b6001870154861061033f5760405162461bcd60e51b815260040161024e906118b2565b600087600101878154811061035057fe5b906000526020600020906003020190506000806103d283600101896002811061037557fe5b600291828204019190066010029054906101000a90046001600160801b03166001600160801b0316846000018a600281106103ac57fe5b600291828204019190066010029054906101000a9004600f0b600f0b888a600f0b610db3565b915091506103e76103e283610d5c565b610eeb565b8360010189600281106103f657fe5b600291828204019190066010026101000a8154816001600160801b0302191690836001600160801b031602179055506104388185610f2f90919063ffffffff16565b935050506000806104a283600201896002811061045157fe5b600291828204019190066010029054906101000a9004600f0b600f0b846000018a6002811061047c57fe5b600291828204019190066010029054906101000a9004600f0b600f0b878a600f0b610db3565b915091506104af82610cf3565b8360020189600281106104be57fe5b600291828204019190066010026101000a8154816001600160801b030219169083600f0b6001600160801b031602179055506105038185610f9490919063ffffffff16565b8a54909450610524925061051f9150600f90810b900b84610f2f565b610cf3565b88546001600160801b0319166001600160801b03600f92830b161789556105829061051f9087900b83896002811061055857fe5b600291828204019190066010029054906101000a9004600f0b600f0b610f2f90919063ffffffff16565b81876002811061058e57fe5b600291828204019190066010026101000a8154816001600160801b030219169083600f0b6001600160801b03160217905550509695505050505050565b6002830154829060ff16156105f25760405162461bcd60e51b815260040161024e90611896565b604080516060810182528554600f90810b810b900b8152600186018054835160208281028201810190955281815260009461079a94938a938286019392889084015b8282101561077b576000848152602090206040805160a0810190915290600384020181606081018260028282826020028201916000905b82829054906101000a9004600f0b600f0b81526020019060100190602082600f0104928301926001038202915080841161066b575050509284525050604080518082019182905260209093019291506001840190600290826000855b82829054906101000a90046001600160801b03166001600160801b031681526020019060100190602082600f010492830192600103820291508084116106c757505050928452505060408051808201918290526020909301929150600284810191826000855b82829054906101000a9004600f0b600f0b81526020019060100190602082600f0104928301926001038202915080841161072d57905050505050508152505081526020019060010190610634565b505050908252506002919091015460ff16151560209091015284610ff9565b604080516060810182528754600f90810b810b900b81526001880180548351602082810282018101909552818152949550600094610945948b93818601939091889084015b82821015610926576000848152602090206040805160a0810190915290600384020181606081018260028282826020028201916000905b82829054906101000a9004600f0b600f0b81526020019060100190602082600f01049283019260010382029150808411610816575050509284525050604080518082019182905260209093019291506001840190600290826000855b82829054906101000a90046001600160801b03166001600160801b031681526020019060100190602082600f0104928301926001038202915080841161087257505050928452505060408051808201918290526020909301929150600284810191826000855b82829054906101000a9004600f0b600f0b81526020019060100190602082600f010492830192600103820291508084116108d8579050505050505081525050815260200190600101906107df565b505050908252506002919091015460ff1615156020909101528561104d565b905080820360008190038612801561095d5750600081135b80156109695750600086125b15610975578060000393505b865461098c9061051f90600f90810b900b86610f2f565b87546001600160801b0319166001600160801b03600f92830b16178089556040805160608101825291830b830b90920b81526001890180548351602080830282018101909552818152610b4d948c9381860193909160009084015b82821015610b2e576000848152602090206040805160a0810190915290600384020181606081018260028282826020028201916000905b82829054906101000a9004600f0b600f0b81526020019060100190602082600f01049283019260010382029150808411610a1e575050509284525050604080518082019182905260209093019291506001840190600290826000855b82829054906101000a90046001600160801b03166001600160801b031681526020019060100190602082600f01049283019260010382029150808411610a7a57505050928452505060408051808201918290526020909301929150600284810191826000855b82829054906101000a9004600f0b600f0b81526020019060100190602082600f01049283019260010382029150808411610ae0579050505050505081525050815260200190600101906109e7565b505050908252506002919091015460ff1615156020909101528661106d565b15610b6a5760405162461bcd60e51b815260040161024e9061187a565b5050509392505050565b600082610b8357506000610c20565b82600019148015610b975750600160ff1b82145b15610bd35760405162461bcd60e51b81526004018080602001828103825260278152602001806119596027913960400191505060405180910390fd5b82820282848281610be057fe5b0514610c1d5760405162461bcd60e51b81526004018080602001828103825260278152602001806119596027913960400191505060405180910390fd5b90505b92915050565b600081610c7a576040805162461bcd60e51b815260206004820181905260248201527f5369676e6564536166654d6174683a206469766973696f6e206279207a65726f604482015290519081900360640190fd5b81600019148015610c8e5750600160ff1b83145b15610cca5760405162461bcd60e51b81526004018080602001828103825260218152602001806119176021913960400191505060405180910390fd5b6000828481610cd557fe5b05949350505050565b6000818313610ced5782610c1d565b50919050565b60006f7fffffffffffffffffffffffffffffff198212158015610d1957506001607f1b82125b610d545760405162461bcd60e51b81526004018080602001828103825260278152602001806118cf6027913960400191505060405180910390fd5b50805b919050565b600080821215610d54576040805162461bcd60e51b815260206004820181905260248201527f53616665436173743a2076616c7565206d75737420626520706f736974697665604482015290519081900360640190fd5b60008080610dc18685610f2f565b9050851580610ddb5750600086138015610ddb5750600084135b80610df15750600086128015610df15750600084125b15610e4157610e3a610e0b610e068887610f2f565b61108e565b6101c4610e21610e1a8861108e565b8990610b74565b610e34610e2d8b61108e565b8c90610b74565b90610f2f565b9250610ee1565b600086138015610e515750600084125b8015610e5d5750600081135b80610e7f5750600086128015610e735750600084135b8015610e7f5750600081125b15610eb3578692506305f5e100610ea4610e998786610f94565b600087900390610b74565b81610eab57fe5b059150610ee1565b8015610ebd578492505b6305f5e100610ed6610ecf878a610f94565b8890610b74565b81610edd57fe5b0591505b5094509492505050565b6000600160801b8210610d545760405162461bcd60e51b81526004018080602001828103825260278152602001806118cf6027913960400191505060405180910390fd5b6000828201818312801590610f445750838112155b80610f595750600083128015610f5957508381125b610c1d5760405162461bcd60e51b81526004018080602001828103825260218152602001806118f66021913960400191505060405180910390fd5b6000818303818312801590610fa95750838113155b80610fbe5750600083128015610fbe57508381135b610c1d5760405162461bcd60e51b81526004018080602001828103825260248152602001806119a86024913960400191505060405180910390fd5b8151600090600f0b815b8460200151518110156110455761103b6110348660200151838151811061102657fe5b60200260200101518661109f565b8390610f2f565b9150600101611003565b509392505050565b600080611059846110bc565b905061106581846110fd565b949350505050565b60008061107a8484610ff9565b9050611086848461104d565b139392505050565b600080821215610d54575060000390565b6000610c1d6110b2848460600151611280565b610e3485856112a7565b6110c46114eb565b60005b6002811015610ced576110da83826112ce565b8282600281106110e657fe5b600f92830b90920b602090920201526001016110c7565b600080611193610e066111406305f5e1006101c46111356305f5e100896040015160006002811061112a57fe5b602002015190610f2f565b8951600f0b90610b74565b610e3468056bc75e2d631000006101c4600261118d8b60016020020151600f0b61118d61117c6305f5e1008e6040015160016002811061112a57fe5b8d516001600160801b031690610b74565b90610b74565b90506111f76111f0610e0669d3c21bcecceda10000006101c48860016020020151600f0b61118d600261118d6111d86305f5e1008d6040015160016002811061112a57fe5b8c5161118d906101f4906001600160801b0316610b74565b829061132f565b9050600064e8d4a5100061122d8361122787600001516001600160801b03166101f461138990919063ffffffff16565b90611389565b8161123457fe5b86519190049150600f0b15158061125157506020850151600f0b15155b80156112615750640ba43b740081105b1561126e5750640ba43b74005b611277816113e2565b95945050505050565b60008060005b60028110156110455761129d611034868387611426565b9150600101611286565b60008060005b6002811015611045576112c4611034868387611489565b91506001016112ad565b6000805b8360200151518110156113285761131e61051f856020015183815181106112f557fe5b602002602001015160000151856002811061130c57fe5b6020020151600f85810b91900b610f2f565b91506001016112d2565b5092915050565b600082820183811015610c1d576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b60008261139857506000610c20565b828202828482816113a557fe5b0414610c1d5760405162461bcd60e51b81526004018080602001828103825260218152602001806119386021913960400191505060405180910390fd5b6000600160ff1b8210610d545760405162461bcd60e51b81526004018080602001828103825260288152602001806119806028913960400191505060405180910390fd5b6000806114798560000151856002811061143c57fe5b6020020151600f0b61118d85876002811061145357fe5b6020020151600f0b8860400151886002811061146b57fe5b6020020151600f0b90610f94565b6305f5e100900595945050505050565b6000806114798560000151856002811061149f57fe5b6020020151600f0b61118d6114d0886020015188600281106114bd57fe5b60200201516001600160801b03166113e2565b866020015188600281106114e057fe5b602002015190610f94565b60405180604001604052806002906020820280368337509192915050565b6001830191839082156115a15791602002820160005b8382111561156c57835183826101000a8154816001600160801b030219169083600f0b6001600160801b031602179055509260200192601001602081600f0104928301926001030261151f565b801561159f5782816101000a8154906001600160801b030219169055601001602081600f0104928301926001030261156c565b505b506115ad929150611611565b5090565b6001830191839082156115a15791602002820160005b8382111561156c57835183826101000a8154816001600160801b0302191690836001600160801b031602179055509260200192601001602081600f010492830192600103026115c7565b5b808211156115ad5760008155600101611612565b600082601f830112611636578081fd5b6040516040810181811067ffffffffffffffff8211171561165357fe5b8060405250808385604086011115611669578384fd5b835b60028110156116925761167d82611701565b8352602092830192919091019060010161166b565b509195945050505050565b600082601f8301126116ad578081fd5b6040516040810181811067ffffffffffffffff821117156116ca57fe5b80604052508083856040860111156116e0578384fd5b835b60028110156116925781358352602092830192909101906001016116e2565b8035600f81900b8114610d5757600080fd5b600060208284031215611724578081fd5b5035919050565b60008060006060848603121561173f578182fd5b505081359360208301359350604090920135919050565b600080600083850361012081121561176c578384fd5b843593506020850135925060e0603f1982011215611788578182fd5b506040516080810181811067ffffffffffffffff821117156117a657fe5b60409081528501356001600160801b03811681146117c2578283fd5b81526117d1866060870161169d565b60208201526117e38660a0870161169d565b60408201526117f58660e08701611626565b6060820152809150509250925092565b60008060008060008060c0878903121561181d578182fd5b86359550602087013594506040870135935061183b60608801611701565b92506080870135915060a087013590509295509295509295565b90815260200190565b602080825260029082015261150d60f21b604082015260600190565b602080825260029082015261054360f41b604082015260600190565b6020808252600290820152612a1960f11b604082015260600190565b602080825260029082015261543360f01b60408201526060019056fe53616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974735369676e6564536166654d6174683a206164646974696f6e206f766572666c6f775369676e6564536166654d6174683a206469766973696f6e206f766572666c6f77536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f775369676e6564536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f7753616665436173743a2076616c756520646f65736e27742066697420696e20616e20696e743235365369676e6564536166654d6174683a207375627472616374696f6e206f766572666c6f77a2646970667358221220096fecab64afa366d9e5e301c021c02cf1bdc94c7c50a4e00d0d12235f0e49b864736f6c63430007060033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100565760003560e01c80631bc045821461005b578063652aa4831461007d578063a8ffb3b9146100b3578063e69e266d146100d3575b600080fd5b81801561006757600080fd5b5061007b610076366004611713565b6100f3565b005b81801561008957600080fd5b5061009d61009836600461172b565b610198565b6040516100aa9190611855565b60405180910390f35b8180156100bf57600080fd5b5061009d6100ce366004611805565b610226565b8180156100df57600080fd5b5061009d6100ee366004611756565b6105cb565b60005b60018201548110156101725760005b60028110156101695782600101828154811061011d57fe5b9060005260206000209060030201600001816002811061013957fe5b600291828204019190066010029054906101000a9004600f0b600f0b60001461016157600080fd5b600101610105565b506001016100f6565b5080546000600f91820b90910b12156101955760028101805460ff191660011790555b50565b8254600090600f90810b900b81126101b25750600061021f565b60006101ca6127106101c48686610b74565b90610c26565b85549091506101e1908290600f90810b900b610cde565b90506101ec81610cf3565b8554600f81810b9290920390910b6001600160801b03166001600160801b031990911617855561021b81610d5c565b9150505b9392505050565b600286015460009060ff16156102575760405162461bcd60e51b815260040161024e90611896565b60405180910390fd5b83600f0b6000141561027b5760405162461bcd60e51b815260040161024e9061185e565b600187015486141561031c5761028f6114eb565b6102976114eb565b61029f6114eb565b6040805160608101825284815260208082018590529181018390526001808d01805491820181556000908152929092208151919260030201906102e59082906002611509565b5060208201516102fb90600183019060026115b1565b5060408201516103119060028084019190611509565b50505050505061033f565b6001870154861061033f5760405162461bcd60e51b815260040161024e906118b2565b600087600101878154811061035057fe5b906000526020600020906003020190506000806103d283600101896002811061037557fe5b600291828204019190066010029054906101000a90046001600160801b03166001600160801b0316846000018a600281106103ac57fe5b600291828204019190066010029054906101000a9004600f0b600f0b888a600f0b610db3565b915091506103e76103e283610d5c565b610eeb565b8360010189600281106103f657fe5b600291828204019190066010026101000a8154816001600160801b0302191690836001600160801b031602179055506104388185610f2f90919063ffffffff16565b935050506000806104a283600201896002811061045157fe5b600291828204019190066010029054906101000a9004600f0b600f0b846000018a6002811061047c57fe5b600291828204019190066010029054906101000a9004600f0b600f0b878a600f0b610db3565b915091506104af82610cf3565b8360020189600281106104be57fe5b600291828204019190066010026101000a8154816001600160801b030219169083600f0b6001600160801b031602179055506105038185610f9490919063ffffffff16565b8a54909450610524925061051f9150600f90810b900b84610f2f565b610cf3565b88546001600160801b0319166001600160801b03600f92830b161789556105829061051f9087900b83896002811061055857fe5b600291828204019190066010029054906101000a9004600f0b600f0b610f2f90919063ffffffff16565b81876002811061058e57fe5b600291828204019190066010026101000a8154816001600160801b030219169083600f0b6001600160801b03160217905550509695505050505050565b6002830154829060ff16156105f25760405162461bcd60e51b815260040161024e90611896565b604080516060810182528554600f90810b810b900b8152600186018054835160208281028201810190955281815260009461079a94938a938286019392889084015b8282101561077b576000848152602090206040805160a0810190915290600384020181606081018260028282826020028201916000905b82829054906101000a9004600f0b600f0b81526020019060100190602082600f0104928301926001038202915080841161066b575050509284525050604080518082019182905260209093019291506001840190600290826000855b82829054906101000a90046001600160801b03166001600160801b031681526020019060100190602082600f010492830192600103820291508084116106c757505050928452505060408051808201918290526020909301929150600284810191826000855b82829054906101000a9004600f0b600f0b81526020019060100190602082600f0104928301926001038202915080841161072d57905050505050508152505081526020019060010190610634565b505050908252506002919091015460ff16151560209091015284610ff9565b604080516060810182528754600f90810b810b900b81526001880180548351602082810282018101909552818152949550600094610945948b93818601939091889084015b82821015610926576000848152602090206040805160a0810190915290600384020181606081018260028282826020028201916000905b82829054906101000a9004600f0b600f0b81526020019060100190602082600f01049283019260010382029150808411610816575050509284525050604080518082019182905260209093019291506001840190600290826000855b82829054906101000a90046001600160801b03166001600160801b031681526020019060100190602082600f0104928301926001038202915080841161087257505050928452505060408051808201918290526020909301929150600284810191826000855b82829054906101000a9004600f0b600f0b81526020019060100190602082600f010492830192600103820291508084116108d8579050505050505081525050815260200190600101906107df565b505050908252506002919091015460ff1615156020909101528561104d565b905080820360008190038612801561095d5750600081135b80156109695750600086125b15610975578060000393505b865461098c9061051f90600f90810b900b86610f2f565b87546001600160801b0319166001600160801b03600f92830b16178089556040805160608101825291830b830b90920b81526001890180548351602080830282018101909552818152610b4d948c9381860193909160009084015b82821015610b2e576000848152602090206040805160a0810190915290600384020181606081018260028282826020028201916000905b82829054906101000a9004600f0b600f0b81526020019060100190602082600f01049283019260010382029150808411610a1e575050509284525050604080518082019182905260209093019291506001840190600290826000855b82829054906101000a90046001600160801b03166001600160801b031681526020019060100190602082600f01049283019260010382029150808411610a7a57505050928452505060408051808201918290526020909301929150600284810191826000855b82829054906101000a9004600f0b600f0b81526020019060100190602082600f01049283019260010382029150808411610ae0579050505050505081525050815260200190600101906109e7565b505050908252506002919091015460ff1615156020909101528661106d565b15610b6a5760405162461bcd60e51b815260040161024e9061187a565b5050509392505050565b600082610b8357506000610c20565b82600019148015610b975750600160ff1b82145b15610bd35760405162461bcd60e51b81526004018080602001828103825260278152602001806119596027913960400191505060405180910390fd5b82820282848281610be057fe5b0514610c1d5760405162461bcd60e51b81526004018080602001828103825260278152602001806119596027913960400191505060405180910390fd5b90505b92915050565b600081610c7a576040805162461bcd60e51b815260206004820181905260248201527f5369676e6564536166654d6174683a206469766973696f6e206279207a65726f604482015290519081900360640190fd5b81600019148015610c8e5750600160ff1b83145b15610cca5760405162461bcd60e51b81526004018080602001828103825260218152602001806119176021913960400191505060405180910390fd5b6000828481610cd557fe5b05949350505050565b6000818313610ced5782610c1d565b50919050565b60006f7fffffffffffffffffffffffffffffff198212158015610d1957506001607f1b82125b610d545760405162461bcd60e51b81526004018080602001828103825260278152602001806118cf6027913960400191505060405180910390fd5b50805b919050565b600080821215610d54576040805162461bcd60e51b815260206004820181905260248201527f53616665436173743a2076616c7565206d75737420626520706f736974697665604482015290519081900360640190fd5b60008080610dc18685610f2f565b9050851580610ddb5750600086138015610ddb5750600084135b80610df15750600086128015610df15750600084125b15610e4157610e3a610e0b610e068887610f2f565b61108e565b6101c4610e21610e1a8861108e565b8990610b74565b610e34610e2d8b61108e565b8c90610b74565b90610f2f565b9250610ee1565b600086138015610e515750600084125b8015610e5d5750600081135b80610e7f5750600086128015610e735750600084135b8015610e7f5750600081125b15610eb3578692506305f5e100610ea4610e998786610f94565b600087900390610b74565b81610eab57fe5b059150610ee1565b8015610ebd578492505b6305f5e100610ed6610ecf878a610f94565b8890610b74565b81610edd57fe5b0591505b5094509492505050565b6000600160801b8210610d545760405162461bcd60e51b81526004018080602001828103825260278152602001806118cf6027913960400191505060405180910390fd5b6000828201818312801590610f445750838112155b80610f595750600083128015610f5957508381125b610c1d5760405162461bcd60e51b81526004018080602001828103825260218152602001806118f66021913960400191505060405180910390fd5b6000818303818312801590610fa95750838113155b80610fbe5750600083128015610fbe57508381135b610c1d5760405162461bcd60e51b81526004018080602001828103825260248152602001806119a86024913960400191505060405180910390fd5b8151600090600f0b815b8460200151518110156110455761103b6110348660200151838151811061102657fe5b60200260200101518661109f565b8390610f2f565b9150600101611003565b509392505050565b600080611059846110bc565b905061106581846110fd565b949350505050565b60008061107a8484610ff9565b9050611086848461104d565b139392505050565b600080821215610d54575060000390565b6000610c1d6110b2848460600151611280565b610e3485856112a7565b6110c46114eb565b60005b6002811015610ced576110da83826112ce565b8282600281106110e657fe5b600f92830b90920b602090920201526001016110c7565b600080611193610e066111406305f5e1006101c46111356305f5e100896040015160006002811061112a57fe5b602002015190610f2f565b8951600f0b90610b74565b610e3468056bc75e2d631000006101c4600261118d8b60016020020151600f0b61118d61117c6305f5e1008e6040015160016002811061112a57fe5b8d516001600160801b031690610b74565b90610b74565b90506111f76111f0610e0669d3c21bcecceda10000006101c48860016020020151600f0b61118d600261118d6111d86305f5e1008d6040015160016002811061112a57fe5b8c5161118d906101f4906001600160801b0316610b74565b829061132f565b9050600064e8d4a5100061122d8361122787600001516001600160801b03166101f461138990919063ffffffff16565b90611389565b8161123457fe5b86519190049150600f0b15158061125157506020850151600f0b15155b80156112615750640ba43b740081105b1561126e5750640ba43b74005b611277816113e2565b95945050505050565b60008060005b60028110156110455761129d611034868387611426565b9150600101611286565b60008060005b6002811015611045576112c4611034868387611489565b91506001016112ad565b6000805b8360200151518110156113285761131e61051f856020015183815181106112f557fe5b602002602001015160000151856002811061130c57fe5b6020020151600f85810b91900b610f2f565b91506001016112d2565b5092915050565b600082820183811015610c1d576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b60008261139857506000610c20565b828202828482816113a557fe5b0414610c1d5760405162461bcd60e51b81526004018080602001828103825260218152602001806119386021913960400191505060405180910390fd5b6000600160ff1b8210610d545760405162461bcd60e51b81526004018080602001828103825260288152602001806119806028913960400191505060405180910390fd5b6000806114798560000151856002811061143c57fe5b6020020151600f0b61118d85876002811061145357fe5b6020020151600f0b8860400151886002811061146b57fe5b6020020151600f0b90610f94565b6305f5e100900595945050505050565b6000806114798560000151856002811061149f57fe5b6020020151600f0b61118d6114d0886020015188600281106114bd57fe5b60200201516001600160801b03166113e2565b866020015188600281106114e057fe5b602002015190610f94565b60405180604001604052806002906020820280368337509192915050565b6001830191839082156115a15791602002820160005b8382111561156c57835183826101000a8154816001600160801b030219169083600f0b6001600160801b031602179055509260200192601001602081600f0104928301926001030261151f565b801561159f5782816101000a8154906001600160801b030219169055601001602081600f0104928301926001030261156c565b505b506115ad929150611611565b5090565b6001830191839082156115a15791602002820160005b8382111561156c57835183826101000a8154816001600160801b0302191690836001600160801b031602179055509260200192601001602081600f010492830192600103026115c7565b5b808211156115ad5760008155600101611612565b600082601f830112611636578081fd5b6040516040810181811067ffffffffffffffff8211171561165357fe5b8060405250808385604086011115611669578384fd5b835b60028110156116925761167d82611701565b8352602092830192919091019060010161166b565b509195945050505050565b600082601f8301126116ad578081fd5b6040516040810181811067ffffffffffffffff821117156116ca57fe5b80604052508083856040860111156116e0578384fd5b835b60028110156116925781358352602092830192909101906001016116e2565b8035600f81900b8114610d5757600080fd5b600060208284031215611724578081fd5b5035919050565b60008060006060848603121561173f578182fd5b505081359360208301359350604090920135919050565b600080600083850361012081121561176c578384fd5b843593506020850135925060e0603f1982011215611788578182fd5b506040516080810181811067ffffffffffffffff821117156117a657fe5b60409081528501356001600160801b03811681146117c2578283fd5b81526117d1866060870161169d565b60208201526117e38660a0870161169d565b60408201526117f58660e08701611626565b6060820152809150509250925092565b60008060008060008060c0878903121561181d578182fd5b86359550602087013594506040870135935061183b60608801611701565b92506080870135915060a087013590509295509295509295565b90815260200190565b602080825260029082015261150d60f21b604082015260600190565b602080825260029082015261054360f41b604082015260600190565b6020808252600290820152612a1960f11b604082015260600190565b602080825260029082015261543360f01b60408201526060019056fe53616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974735369676e6564536166654d6174683a206164646974696f6e206f766572666c6f775369676e6564536166654d6174683a206469766973696f6e206f766572666c6f77536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f775369676e6564536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f7753616665436173743a2076616c756520646f65736e27742066697420696e20616e20696e743235365369676e6564536166654d6174683a207375627472616374696f6e206f766572666c6f77a2646970667358221220096fecab64afa366d9e5e301c021c02cf1bdc94c7c50a4e00d0d12235f0e49b864736f6c63430007060033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "decreaseLiquidationReward(TraderVaultLib.TraderVault storage,int256,int256)": {
        "params": {
          "_liquidationFee": "liquidation fee rate",
          "_minCollateral": "min collateral",
          "_traderVault": "trader vault object"
        }
      },
      "setInsolvencyFlagIfNeeded(TraderVaultLib.TraderVault storage)": {
        "params": {
          "_traderVault": "trader vault object"
        }
      },
      "updateUsdcPosition(TraderVaultLib.TraderVault storage,int256,IPerpetualMarketCore.TradePriceInfo)": {
        "params": {
          "_tradePriceInfo": "trade price info",
          "_traderVault": "trader vault object",
          "_usdcPositionToAdd": "amount to add. if positive then increase amount, if negative then decrease amount."
        },
        "returns": {
          "finalUsdcPosition": "positive means amount of deposited margin and negative means amount of withdrawn margin."
        }
      },
      "updateVault(TraderVaultLib.TraderVault storage,uint256,uint256,int128,uint256,int256)": {
        "params": {
          "_fundingFeePerPosition": "entry funding fee paid per position",
          "_positionPerpetual": "amount of position to increase or decrease",
          "_productId": "product id",
          "_subVaultIndex": "index of sub-vault",
          "_tradePrice": "trade price",
          "_traderVault": "trader vault object"
        }
      }
    },
    "stateVariables": {
      "MIN_MARGIN": {
        "details": "minimum margin is 500 USDC"
      },
      "RISK_PARAM_FOR_VAULT": {
        "details": "risk parameter for MinCollateral calculation is 5.0%"
      }
    },
    "title": "TraderVaultLib",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "decreaseLiquidationReward(TraderVaultLib.TraderVault storage,int256,int256)": {
        "notice": "Decreases liquidation reward from usdc position"
      },
      "setInsolvencyFlagIfNeeded(TraderVaultLib.TraderVault storage)": {
        "notice": "Set insolvency flag if needed If PositionValue is negative, set insolvency flag."
      },
      "updateUsdcPosition(TraderVaultLib.TraderVault storage,int256,IPerpetualMarketCore.TradePriceInfo)": {
        "notice": "Updates USDC position"
      },
      "updateVault(TraderVaultLib.TraderVault storage,uint256,uint256,int128,uint256,int256)": {
        "notice": "Updates positions in the vault"
      }
    },
    "notice": "TraderVaultLib has functions to calculate position value and minimum collateral for implementing cross margin wallet. Data Structure  Vault  - PositionUSDC  - SubVault0(PositionPerpetuals, EntryPrices, entryFundingFee)  - SubVault1(PositionPerpetuals, EntryPrices, entryFundingFee)  - ...  PositionPerpetuals = [PositionSqueeth, PositionFuture]  EntryPrices = [EntryPriceSqueeth, EntryPriceFuture]  entryFundingFee = [entryFundingFeeqeeth, FundingFeeEntryValueFuture] Error codes  T0: PositionValue must be greater than MinCollateral  T1: PositionValue must be less than MinCollateral  T2: Vault is insolvent  T3: subVaultIndex is too large  T4: position must not be 0",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}